{"version":3,"file":"static/js/1235.60486847.chunk.js","mappings":"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","sources":["components/ngl-viewer/use-default-representations/index.js","webpack://mdposit/./src/components/viewer-with-controls/representations-manager/style.module.css?be77","components/viewer-with-controls/representations-manager/index.js","utils/storage/index.js","components/molstar-viewer/molstar-parser/index.ts","components/molstar-viewer/get-frames/index.js","webpack://mdposit/./src/components/molstar-viewer/style.module.css?3a43","components/molstar-viewer/index.js","components/ngl-viewer/payload-to-ngl-file/index.js","components/ngl-viewer/get-frames/index.js","webpack://mdposit/./src/components/ngl-viewer/style.module.css?eaa8","components/ngl-viewer/index.js","utils/connection-level/index.js","webpack://mdposit/./src/components/viewer-with-controls/style.module.css?bc6d","components/viewer-with-controls/index.js","utils/tooltip-position-manager/index.js"],"sourcesContent":["// React logic\nimport { useMemo, useContext } from 'react';\n\nimport { ProjectCtx, PdbCtx } from '../../../contexts';\n\nimport { nglSelection2residueIndices, nglSelectionExists } from '../../../utils/topology-manager';\n\n// Use this hook to get the memoized NGL default representations\nconst useDefaultRepresentations = () => {\n  // Get the current project metadata and chains\n  const { chains, metadata, topology } = useContext(ProjectCtx);\n  // Get current structure\n  const { file: structure } = useContext(PdbCtx);\n  //console.log(structure.residueMap.get(0).isCg());\n  // Set the chains to be represented in the NGL viewer by default\n  // WARNING: This is experimental and may have some bugs\n  const defaultRepresentations = useMemo(() => {\n    if (!topology) return [];\n    const reps = [];\n    const ligands = metadata && metadata.LIGANDS;\n    if (metadata && chains) {\n      const chainnames = metadata.CHAINNAMES;\n      // Represent each protein chain\n      if (chainnames) {\n        for (const chain of chains) {\n          const name = chainnames[chain];\n          reps.push({\n            name: name ? name + ' (Chain ' + chain + ')' : 'Chain ' + chain,\n            selection: ':' + chain,\n          });\n        }\n      }\n      // If chainnames are not defined then set a general representation\n      else {\n        const generalRepresentations = [\n          { name: 'Protein', selection: 'protein' },\n          { name: 'Nucleic acids', selection: 'nucleic' }\n        ]\n        // Add the representation only if it contains any atom\n        generalRepresentations.forEach(rep => {\n          const exists = nglSelectionExists(rep.selection, structure);\n          if (exists) reps.push(rep);\n        });\n      }\n\n      // Represent the mebrane if exist\n      /*\n          if (metadata.MEMBRANE !== 'No')\n              reps.push({\n              selection: '(not polymer or hetero) and not (water or ion)',\n              name: metadata.MEMBRANE,\n              type: 'licorice',\n              opacity: 0.5,\n              });\n          */\n      // Represent all chains which are not in the 'chains' and 'ligands' list in licorice\n      if (chainnames && !Array.isArray(chainnames)) {\n        const chainsAndNames = Object.entries(chainnames);\n        chainsAndNames.forEach(([chain, name]) => {\n          // Check if the chain is in the protein chains\n          const isProtein = chains.indexOf(chain) !== -1;\n          if (isProtein) return;\n          // Check if the chain is full ligand\n          // DANI: No se ha probado\n          const topologyChain = topology.getChainByName(chain);\n          const isLigand = topologyChain.residues.every(residue => residue.isLigand);\n          // If there is any coincidence then skip this chainname\n          if (isLigand) return;\n          reps.push({\n            name: name,\n            selection: ':' + chain,\n            type: 'licorice',\n            color: 'purple',\n            opacity: 0.5,\n          });\n        });\n      }\n    }\n    // If there is no metadata/chains then set up a defualt generic representation\n    else {\n      reps.push({ name: 'Main structure' });\n    }\n\n    // Display ligands\n    if (ligands) {\n      for (const ligand of ligands) {\n        // New system: ligands are pubchem ids\n        if (typeof ligand === 'string') {\n          // Get ligand reisude indcies\n          const ligandResidueIndices = topology.getReferenceResidueIndices(ligand);\n          if (!ligandResidueIndices || ligandResidueIndices.length === 0) continue;\n          // Transform the residue indices to a NGL selection\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(ligandResidueIndices);\n          // Add the representation\n          reps.push({\n            name: ligand,\n            selection: nglSelection,\n            type: 'ball+stick',\n            color: 'element'\n          });\n        }\n        // Old system: ligands are objects which may have a ngl selection\n        else{\n          if (!ligand.ngl) continue;\n          reps.push({\n            name: ligand.name,\n            selection: ligand.ngl,\n            type: 'licorice',\n          });\n        }\n        \n      }\n    }\n\n    // Add a representation for ions in spacefill in case there are residues with 1 atom\n    const singleAtomIndices = []\n    topology.residueAtomIndices.forEach(atomIndices => {\n      if (atomIndices.length > 1) return;\n      singleAtomIndices.push(atomIndices[0]);\n    })\n    if (singleAtomIndices.length > 0) {\n      const singleAtomSelection = '@' + singleAtomIndices.join(',');\n      reps.push({\n        name: 'Ions',\n        selection: singleAtomSelection,\n        type: 'spacefill',\n        color: 'element',\n      });\n    }\n\n    // Represent \"Other\" residues in low opacity grey licorice\n    // Get all residues which are not already included on any previous section\n    // Get also all residues which are represented as cartoon but are not protein or nucleic acid\n    // i.e. residues which would not be represented by now\n    const representedResidues = [];\n    reps.forEach(rep => {\n      const isCartoon = rep.type === undefined || rep.type === 'cartoon';\n      const residues = nglSelection2residueIndices(\n        rep.selection,\n        isCartoon,\n        structure,\n      );\n      representedResidues.push(...residues);\n    });\n    const residuesCount = topology.residueCount;\n    const nonRepresentedResidues = [];\n    for (let i = 0; i < residuesCount; i++) {\n      if (representedResidues.indexOf(i) === -1) nonRepresentedResidues.push(i);\n    }\n    if (nonRepresentedResidues.length > 0) {\n      const {\n        rangedSelection: otherSelection,\n      } = topology.residueIndices2Ngl(nonRepresentedResidues);\n      reps.push({\n        name: 'Other',\n        selection: otherSelection,\n        type: 'licorice',\n        color: 'grey',\n        opacity: 0.3,\n      });\n    }\n\n    return reps;\n  }, [chains, metadata, topology, structure]);\n\n  return defaultRepresentations;\n};\n\nexport default useDefaultRepresentations;\n","// extracted by mini-css-extract-plugin\nexport default {\"popover-slider\":\"style_popover-slider__Rg-SB\",\"tablecard\":\"style_tablecard__1tgr+\",\"nglcard\":\"style_nglcard__xuaa2\",\"paper\":\"style_paper__G3Eus\"};","import React, { memo } from 'react';\n\nimport {\n  Chip,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableRow,\n  TextField,\n  Select,\n  Slider,\n  IconButton,\n} from '@mui/material';\nimport {\n  faEye,\n  faEyeSlash,\n  faPlusCircle,\n} from '@fortawesome/free-solid-svg-icons';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n\nimport style from './style.module.css';\n\nconst availableDrawingMethods = [\n  {\n    label: 'Cartoon',\n    value: 'cartoon',\n  },\n  {\n    label: 'Licorice',\n    value: 'licorice',\n  },\n  {\n    label: 'Ball and stick',\n    value: 'ball+stick',\n  },\n  {\n    label: 'Surface',\n    value: 'surface',\n  },\n  {\n    label: 'Spacefill',\n    value: 'spacefill',\n  },\n  {\n    label: 'Tube',\n    value: 'tube',\n  },\n  {\n    label: 'Trace',\n    value: 'trace',\n  },\n  {\n    label: 'Backbone',\n    value: 'backbone',\n  },\n];\n\n// Check if a value exists inside the available values\nconst DrawingMethodExists = value => {\n  for (const opt of availableDrawingMethods) {\n    if (opt.value === value) return true;\n  }\n  return false;\n};\n\nconst availableColoringMethods = [\n  {\n    label: 'By chain id',\n    value: 'chainid',\n  },\n  {\n    label: 'By residue',\n    value: 'resname',\n  },\n  {\n    label: 'By element',\n    value: 'element',\n  },\n  {\n    label: 'B factor',\n    value: 'bfactor',\n  },\n  {\n    label: 'Electrostatic',\n    value: 'electrostatic',\n  },\n  {\n    label: 'Secondary structure',\n    value: 'sstruc',\n  },\n  {\n    label: 'Uniform',\n    value: 'uniform',\n  },\n];\n\nconst availableColors = [\n  'red',\n  'yellow',\n  'blue',\n  'green',\n  'orange',\n  'purple',\n  'white',\n  'grey',\n  'black',\n];\n\n// Check if a value exists inside the available values\nconst coloringExists = value => {\n  if (value === 'custom') return true;\n  for (const opt of availableColoringMethods) {\n    if (opt.value === value) return true;\n  }\n  for (const opt of availableColors) {\n    if (opt === value) return true;\n  }\n  return false;\n};\n\n// Return a word but with the first letter in upper case\nconst firstLetterUpper = word => word[0].toUpperCase() + word.slice(1);\n\n// Display a huge panel to select which representations must be shown or hidden\n// In addition the user can manage the way these representatios are shown\nconst RepresentationsManager = memo(\n  ({\n    components, // Array with all components\n    representations, // Array with all representations\n    setRepresentations, // Representations setter\n  }) => {\n    return (\n      <>\n        <Table\n          aria-label=\"simple table\"\n          size=\"small\"\n          padding=\"checkbox\"\n          stickyHeader\n        >\n          <TableHead>\n            <TableRow>\n              <TableCell>Name</TableCell>\n              <TableCell align=\"right\">Show</TableCell>\n              <TableCell align=\"right\">Selection</TableCell>\n              <TableCell align=\"right\">Drawing method</TableCell>\n              <TableCell align=\"right\">Coloring method</TableCell>\n              <TableCell align=\"right\">Opacity</TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {representations.map((representation, index) => (\n              <TableRow key={index}>\n                {/* Name */}\n                <TableCell component=\"th\" scope=\"row\">\n                  {representation.name}\n                </TableCell>\n                {/* Show */}\n                <TableCell align=\"right\">\n                  <IconButton\n                    title=\"Show/Hide representation\"\n                    onClick={() =>\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].show = !previousRepresentations[index].show;\n                        return [...previousRepresentations];\n                      })\n                    }\n                    color={'primary'}\n                  >\n                    <FontAwesomeIcon\n                      icon={representation.show ? faEye : faEyeSlash}\n                    />\n                  </IconButton>\n                </TableCell>\n                {/* Selection */}\n                <TableCell align=\"right\">\n                  <TextField\n                    defaultValue={representation.selection}\n                    variant=\"outlined\"\n                    onKeyPress={event => {\n                      if (event.key !== 'Enter') return;\n                      setRepresentations(previousRepresentations => {\n                        if (!event.target || !event.target.value) return previousRepresentations;\n                        previousRepresentations[index].selection = event.target.value;\n                        return [...previousRepresentations];\n                      });\n                    }}\n                    disabled={!representation.custom}\n                    size=\"small\"\n                    margin=\"dense\"\n                  />\n                </TableCell>\n                {/* Drawing method */}\n                <TableCell align=\"right\">\n                  <Select\n                    native\n                    value={representation.type}\n                    onChange={({ target: { value } }) => {\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].type = value;\n                        return [...previousRepresentations];\n                      })\n                    }}\n                  >\n                    {!DrawingMethodExists(representation.type) && (\n                      <option value={representation.type}>\n                        {representation.type}\n                      </option>\n                    )}\n                    {availableDrawingMethods.map((cm, i) => (\n                      <option key={i} value={cm.value}>\n                        {cm.label}\n                      </option>\n                    ))}\n                  </Select>\n                </TableCell>\n                {/* Coloring method */}\n                <TableCell align=\"right\">\n                  <Select\n                    native\n                    value={representation.color}\n                    onChange={({ target: { value } }) => {\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].color = value;\n                        return [...previousRepresentations];\n                      })\n                    }}\n                  >\n                    {!coloringExists(representation.color) && (\n                      <option value={representation.color}>\n                        {representation.color}\n                      </option>\n                    )}\n                    {representation.customScheme && (\n                      <option value={'custom'}>{'Custom'}</option>\n                    )}\n                    {availableColoringMethods.map((cm, i) => (\n                      <option key={i} value={cm.value}>\n                        {cm.label}\n                      </option>\n                    ))}\n                    {availableColors.map((color, i) => (\n                      <option key={i} value={color}>\n                        {firstLetterUpper(color)}\n                      </option>\n                    ))}\n                  </Select>\n                </TableCell>\n                {/* Opacity */}\n                <TableCell align=\"right\">\n                  <Slider\n                    value={representation.opacity * 100}\n                    onChange={(_, value) => {\n                      setRepresentations(previousRepresentations => {\n                        previousRepresentations[index].opacity = value / 100;\n                        return [...previousRepresentations];\n                      })\n                    }}\n                    className={style['popover-slider']}\n                  />\n                </TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n          <TableBody>\n            <TableRow key={'addCustom'}>\n              <TableCell align=\"center\" colSpan={6}>\n                <Chip\n                  icon={<FontAwesomeIcon icon={faPlusCircle} />}\n                  label={'Add representation'}\n                  variant=\"outlined\"\n                  onClick={() =>\n                    setRepresentations(previousRepresentations => {\n                      // Set the default values for the custom representation\n                      const newRepresentation = {\n                        name: 'Custom', show: true,\n                        selection: 'None', type: 'licorice',\n                        color: 'chainid', opacity: 1,\n                        // Link the representation to the first (main) component\n                        component: components[0] && components[0].name,\n                        // Add the custom flag so this representation is treated differently\n                        custom: true,\n                      };\n                      const newRepresentations = [...previousRepresentations, newRepresentation];\n                      return newRepresentations;\n                    })\n                  }\n                />\n              </TableCell>\n            </TableRow>\n          </TableBody>\n        </Table>\n      </>\n    );\n  },\n);\n\nexport default RepresentationsManager;\n","import { schedule } from 'timing-functions';\nimport pck from '../../../package.json';\n\nconst KEY = `${pck.name}-`;\n\nconst MAX_WAIT_TIME = 1000;\n\nexport const get = (key, defaultValue) => {\n  const storedValue = localStorage.getItem(KEY + key);\n  if (storedValue === null) return defaultValue;\n  return JSON.parse(storedValue);\n};\n\nexport const set = (key, value) => {\n  localStorage.setItem(KEY + key, JSON.stringify(value));\n};\n\nexport const setAsync = async (key, value) => {\n  await schedule(MAX_WAIT_TIME);\n  return set(key, value);\n};\n\nexport const deleteAll = () => {\n  Object.keys(localStorage)\n    .filter(key => key.startsWith(KEY))\n    .forEach(key => localStorage.removeItem(key));\n};\n","import { StateTransformer } from 'molstar/lib/mol-state';\nimport { PluginStateObject } from 'molstar/lib/mol-plugin-state/objects';\nimport { Task } from 'molstar/lib/mol-task';\nimport { ParamDefinition as PD } from 'molstar/lib/mol-util/param-definition';\nimport { Coordinates, Time } from 'molstar/lib/mol-model/structure';\n\nconst CreateTransformer = StateTransformer.builderFactory('custom-namespace');\n\nexport const TrajectoryFromCustomData = CreateTransformer({\n    name: 'trajectory-from-custom-data',\n    display: 'Trajectory',\n    from: PluginStateObject.Root,\n    to: PluginStateObject.Molecule.Coordinates,\n    params: {\n        data: PD.Value<Uint8Array>(new Uint8Array(), { isHidden: true }),\n        natoms: PD.Value<number>(0, { isHidden: true }),\n    },\n})({\n    apply({ params }) {\n        return Task.create('Parse atom coordinates', async (ctx) => {\n            //ctx.update({ canAbort: true, message: 'Parsing trajectory...' });\n            return await customParse(params.data, params.natoms);\n        });\n    },\n});\n\n// Parse binary atom coordinates\nasync function customParse (data: Uint8Array, natoms: number) {\n    // Check the number of atoms to not be 0 (the default)\n    if (natoms === 0) throw new Error('Number of atoms is 0');\n    // Each coordinates is a float32 an thus it takes 4 bytes of space\n    const coordSize = 4;\n    // Each atom has 3 coordinates: x, y and z\n    const atomSize = coordSize * 3;\n    // Each frame has coordinates for every atom\n    const frameSize = atomSize * natoms;\n    // Check data contains whole frames\n    if (data.byteLength % frameSize !== 0) throw new Error('Trajectory data ends abruptly');\n    // Calculate the number of frames\n    const nframes = data.byteLength / frameSize;\n    // Convert binary data to coordinates\n    const coordinates = new Float32Array(data);\n    // Set a list with the already read coordinates\n    const frameCoordinates = [];\n    // Keep track of the coordinate we are reading\n    let count = 0;\n    // Iterate over each frame number\n    for (let frame = 0; frame < nframes; frame++) {\n        // Coordinates are saved separately by dimensions, as it is done in molstar\n        const x_coords = new Float32Array(natoms);\n        const y_coords = new Float32Array(natoms);\n        const z_coords = new Float32Array(natoms);\n        // Iterate over each atom number\n        for (let atom = 0; atom < natoms; atom++) {\n            // Read the current atom coordinates\n            x_coords[atom] = coordinates[count]\n            y_coords[atom] = coordinates[count+1];\n            z_coords[atom] = coordinates[count+2];\n            // Update the byte offset\n            count += 3;\n        }\n        // Push the current frame to the overall frames list\n        frameCoordinates.push({\n            x: x_coords,\n            y: y_coords,\n            z: z_coords,\n            // Add a few extra parameters on each frame\n            elementCount: natoms,\n            time: Time(frame, 'step'),\n            xyzOrdering: { isIdentity: true }\n        });\n    }\n    // Set the molstar object for coordinates\n    const molstarCoords = Coordinates.create(\n        frameCoordinates,\n        Time(1, 'step'), // deltaTime\n        Time(0, 'step') // offsetTime\n    );\n    return new PluginStateObject.Molecule.Coordinates(molstarCoords, { label: 'label' });\n}","// This function expects to receive a specific frame or the number of frames to load\n// This function returns a string which specifies the frames to be loaded\n// This string is standarized in a API friendly format\nconst getFrames = (trajectoryFrames, requestedFrames, requestedFrame) => {\n  // only one specific frame loaded, as a projection\n  if (requestedFrame) {\n    return { range: (requestedFrame + 1).toString(), frames: 1 };\n  }\n  // multiple frames loaded, as a trajectory\n  else {\n    if (!trajectoryFrames)\n      throw new Error('Missing number of frames in the trajectory');\n    if (!requestedFrames) throw new Error('Missing number of requested frames');\n    const frameStep = Math.floor(trajectoryFrames / requestedFrames);\n    // Predict how many frames will be returned, which may be different from the requested frames number\n    const returnedFrames = Math.ceil(trajectoryFrames / frameStep);\n    return {\n      range: `${1}:${trajectoryFrames}:${frameStep}`,\n      frames: returnedFrames,\n    };\n  }\n};\n\nexport default getFrames;\n","// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__d6R8E\",\"light-theme\":\"style_light-theme__l3EaT\",\"loading-trajectory\":\"style_loading-trajectory__ciokb\",\"loading-structure\":\"style_loading-structure__ce+kY\",\"tooltip\":\"style_tooltip__KXFgY\"};","import React, {\n  forwardRef,\n  memo,\n  useState,\n  useRef,\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useEffect,\n  useContext,\n} from 'react';\n//import useToggleState from '../../hooks/use-toggle-state';\nimport { useInView } from 'react-intersection-observer';\nimport cn from 'classnames';\n\n// Load molstar logic\n//import { PluginUIContext } from \"molstar/lib/mol-plugin-ui/context\";\nimport { createPluginUI } from 'molstar/lib/mol-plugin-ui/index';\nimport { DefaultPluginUISpec } from 'molstar/lib/mol-plugin-ui/spec';\nimport { TrajectoryFromModelAndCoordinates } from 'molstar/lib/mol-plugin-state/transforms/model';\nimport { AnimateModelIndex } from 'molstar/lib/mol-plugin-state/animation/built-in/model-index';\nimport { createStructureRepresentationParams } from 'molstar/lib/mol-plugin-state/helpers/structure-representation-params';\nimport { StateTransforms } from 'molstar/lib/mol-plugin-state/transforms';\n/*  Might require extra configuration,\nsee https://webpack.js.org/loaders/sass-loader/ for example.\ncreate-react-app should support this natively. */\n//import \"molstar/lib/mol-plugin-ui/skin/light.scss\";\n\n// Load the parser for trajectory coordinates in our format to molstar format\nimport { TrajectoryFromCustomData } from './molstar-parser';\n\nimport getFrames from './get-frames';\n\nimport { ProjectCtx, PdbCtx } from '../../contexts';\n\n//import { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\nimport style from './style.module.css';\n\n// To get frames\nimport { BASE_PATH_PROJECTS, MAIN_STRUCTURE_FILENAME } from '../../utils/constants';\n\n// Used to just wait\nimport { sleep } from 'timing-functions';\n\nimport https from 'https-browserify';\nimport http from 'stream-http';\nimport url from 'url';\n\n// Load the molstar plugin context in a global and accessible place\n//window.molstar = PluginUIContext;\n\n// Customize molstar specifications\n// Here you can see more clues about molstar options:\n//   https://github.com/molstar/molstar/blob/0bf32148afd93a645b44dca6d81e9779e85b4300/src/apps/viewer/app.ts\nconst molstarSpec = DefaultPluginUISpec();\nmolstarSpec.layout = {\n  initial: {\n    // When isExpanded is set true the vertical scroll is blocked\n    isExpanded: false,\n    // DANI: Esto no se que hace, he provado distintos valores y no veo la diferencia\n    // Available options: 'outside', 'portrait', 'landscape' or 'reactive'\n    controlsDisplay: 'reactive',\n    // If showControls is set to true then some logs are rendered in molstar\n    // This is a problem since they offset the molecule and they eclipse the mouse interaction with it\n    // These controls can be hidden by parts firther in the specifications however\n    showControls: false,\n  },\n};\nmolstarSpec.components = {\n  // This is only useful if showControls are set to true\n  controls: {\n    // Hide sequence (question mark in the top right corner)\n    // DANI: Al hacer click no hace nada\n    top: 'none',\n    // Hide console logs (they block the mouse click interaction with the main viewer)\n    bottom: 'none',\n    // Hide left panel (this panels is offsetting and deforming the main viewer very bad)\n    // DANI: Hay un botón pero funciona mal: intenta abrir un desplegable con más botones pero colapsa al momento\n    left: 'none',\n    // DANI: No se que hace esto pero he visto que alguien lo ponía así que yo también\n    remoteState: 'none',\n  },\n};\n\nconst DEFAULT_NUMBER_OF_FRAMES = 25;\n//const DEFAULT_ORIENTATION_TRANSITION_DURATION = 750; // 750 ms\n\nconst frameRangeFormat = /\\?frames=(?<start>\\d+):(?<end>\\d+)(:(?<step>\\d+))?/;\nconst parseFrameRange = frameRange => {\n  // Search in the function's parameter value \"string\" by using a specified regexp format: STEP_FORMAT\n  const parsed = frameRangeFormat.exec(frameRange);\n  if (!parsed) return null;\n  // The 'frameRangeFormat' has 3 defined groups: start, end and step\n  // Use the value from the 3 groups to define and save the desired frames\n  const start = +parsed.groups.start;\n  const end = Math.max(+parsed.groups.end, start); // If the end is less than the start then just use the start\n  const step = +(parsed.groups.step || 1);\n  const frames = Math.floor((end - start) / step) + 1;\n  return { start, end, step, frames };\n};\n\n// Join 2 ArrayBuffer\n// https://stackoverflow.com/questions/10786128/appending-arraybuffers\nfunction appendBuffer(buffer1, buffer2) {\n  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\n// Set the number of bytes per element in trajectory data\nconst BYTES_PER_COORDINATE = 4; // float 32\nconst COORDINATES_PER_ATOM = 3; // x, y and z\nconst BYTES_PER_ATOM = BYTES_PER_COORDINATE * COORDINATES_PER_ATOM;\n\n// Set the NGL player speed limits\n// The actual 'speed' input limits are 0-100\n// The speed set as the time to wait before moving to the next frame in miliseconds\nconst minimumSpeed = 0;\nconst maximumSpeed = 100;\nconst slowestTimeout = 1000;\nconst fastestTimeout = 50;\nconst interpolateSpeed = speed => {\n  return (\n    slowestTimeout +\n    (speed - minimumSpeed) *\n      ((fastestTimeout - slowestTimeout) / (maximumSpeed - minimumSpeed))\n  );\n};\n\nconst defaultHighlightTypes = {\n  atoms: 'spacefill',\n  residues: 'ball+stick',\n  chains: 'ball+stick',\n  selections: 'ball+stick',\n};\n\nconst MolstarViewer = memo(\n  forwardRef(\n    (\n      {\n        className,\n        playing,\n        spinning,\n        smooth,\n        onProgress,\n        onLoad,\n        bounce = false, // Set if the animation, when finished, starts again (false) or goes back (true)\n        requestedFramesNumber = DEFAULT_NUMBER_OF_FRAMES, // The number of frames to be represented\n        selectedAtoms, // Atom index of the atom and residue to be represented\n        selectedResidueIndices, // Residue indices from residues to be highlighted\n        selectedChains, // Chain letters from chains to be represented\n        selectedCustom, // Free NGL selections to be directly represented\n        selectedDistances, // Groups of 2 atoms or residues to be represented as a distance\n        selectedAngles, // Groups of 3 atoms to be represented as an angle\n        selectedRepresentation, // String name of a representation to be painted in yellow color (only 1)\n        snapRepresentations,\n        noTrajectory, // True when only specific frames must be loaded\n        initialFocus, // The ngl selection to be focused by the camera initially\n        darkBackground,\n        perspective,\n        speed,\n        // Hooked values for changing representation parameters\n        drawingMethods,\n        coloringMethods,\n        opacities,\n        components,\n        showRepresentations,\n        nglSelections,\n        // Set the highlight representations types\n        highlightTypes = defaultHighlightTypes,\n      },\n      ref,\n    ) => {\n      // Save the components object into a local constant which can be modified\n      const comps = useMemo(() => components, [components]);\n\n      // If no URL is provided then use the main trajectory // URL to find the trajectory data in the API\n      // True when we just want to display a static structure // Requeste number of frames to display\n      // data from context\n      const {\n        accession,\n        accessionAndMdNumber,\n        fileDescriptors,\n        curatedOrientation,\n        topology: topologyManager,\n      } = useContext(ProjectCtx);\n      const { file: pdbDataFile } = useContext(PdbCtx);\n\n      const [isFirstCompStaged, setIsFirstCompStaged] = useState(false);\n      // The last automatic camera focus\n      const [focus, setFocus] = useState(initialFocus);\n\n      useMemo(() => {\n        //console.log(initialFocus);\n        setFocus(initialFocus);\n      }, [initialFocus]);\n\n      // references\n      const parentRef = useRef(null);\n      const molstarRef = useRef(null);\n      const containerRef = useRef(null);\n      const stageRef = useRef(null);\n      const tooltipRef = useRef(null);\n      const firstTime = useRef(true);\n\n      // in-view hook\n      const [inViewRef, isInView] = useInView();\n\n      // Set the content of the tooltip in JSX format\n      const [tooltipContent, setTooltipContent] = useState(null);\n\n      // Save all http requests so we can abort them all in case the whole component is unmounted\n      const currentRequests = useRef([]);\n\n      // Download topologies ----------------------------------------------------------------------\n\n      // Download all requested topologies: Each component may have a different structure URL.\n      // Set the first component topology as the 'pdbData'\n      // If a topologyURL is provided, download data form the API\n      // Otherwise, use the main structure\n\n      // Set a state to store the topology requests\n      const [requestedTopologies, setRequestedTopologies] = useState([]);\n      // Set also a state to track whenever there is still a downloading topology\n      const [anyLoadingTopology, setAnyLoadingTopology] = useState(false);\n\n      // Find if there are new topology to be requested in the components:\n      // Collect the topology on each component\n      // If the component has no topology specified use the main topology\n      useMemo(() => {\n        setRequestedTopologies(previousRequestedTopologies => {\n          const newRequestedTopologies = [];\n          comps.forEach(comp => {\n            const url = comp.topologyURL || null;\n            // Check if the url is new\n            // Else, skip this url since it has been requested already\n            const allRequestedTopologies = [\n              ...previousRequestedTopologies,\n              ...newRequestedTopologies,\n            ];\n            const current = allRequestedTopologies.find(topology => {\n              return topology.url === url;\n            });\n            if (current) return;\n            // Some urls may be missing\n            // This happens when the component wants the default topology from the pdbData\n            if (url === null) {\n              // Add a request with null url in order to get pdbData as a topology\n              // Do it only once for all components\n              newRequestedTopologies.push({\n                //url: null,\n                //loading: false,\n                // DANI: hardcodeo temporal\n                url: `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/${MAIN_STRUCTURE_FILENAME}`,\n                loading: true,\n                requested: false,\n                error: null,\n              });\n            } else {\n              // Add the topology to the list, so it will be requested to the API\n              newRequestedTopologies.push({\n                url: url,\n                loading: true,\n                requested: false,\n                error: null,\n              });\n              setAnyLoadingTopology(true);\n            }\n          });\n          return [...previousRequestedTopologies, ...newRequestedTopologies];\n        });\n      }, [comps, setRequestedTopologies, accession]);\n\n      // Set a state to store the downloaded topologies\n      const [topologies, setTopologies] = useState([]);\n\n      // Download all requested topologies from the API\n      useEffect(() => {\n        // Make an API request from each url\n        requestedTopologies.forEach((requestedTopology, t) => {\n          // Check if the requested url has the data already downloaded\n          // If so, skip this request\n          if (requestedTopology.file) return;\n          // If the topology failed to load do not try it again\n          if (requestedTopology.error) return;\n          // If the topology has been already requested do not request it again\n          if (requestedTopology.requested) return;\n          // If there is no URL load the context pdbData\n          if (requestedTopology.url === null) {\n            // WARNING: The '[...previous]' is essential to make the array object change\n            // This is important, since the 'topologies' object is used as a dependency further\n            // And if we do not change the array then the change is not detected\n            setTopologies(previous => {\n              requestedTopology.loading = false;\n              // Then check the loading state of all requested topologies and update the overall loading state\n              const anyLoading = requestedTopologies.some(t => t.loading);\n              setAnyLoadingTopology(anyLoading);\n              // The topology with the pdb data has not url\n              const topology = { url: null, file: pdbDataFile };\n              return [...previous, topology];\n            });\n          }\n          // If there is an URL\n          else {\n            requestedTopology.requested = true;\n            // Request the API\n            // http exception is added for local testing in http://localhost\n            const getter =\n              requestedTopology.url.substring(0, 5) === 'https'\n                ? https.get\n                : http.get;\n            let file = '';\n            const request = getter(\n              url.parse(requestedTopology.url),\n              response => {\n                // Get the whole response and then add it to the topologies\n                response\n                  .on('data', chunk => {\n                    file += chunk;\n                  })\n                  .on('end', () => {\n                    setTopologies(previous => {\n                      requestedTopology.loading = false;\n                      // Then check the loading state of all requested topologies and update the overall loading state\n                      const anyLoading = requestedTopologies.some(\n                        t => t.loading,\n                      );\n                      setAnyLoadingTopology(anyLoading);\n                      const topology = {\n                        url: requestedTopology.url,\n                        file: file,\n                      };\n                      return [...previous, topology];\n                    });\n                  })\n                  .on('error', error => {\n                    requestedTopology.loading = false;\n                    // Then check the loading state of all requested topologies and update the overall loading state\n                    const anyLoading = requestedTopologies.some(t => t.loading);\n                    setAnyLoadingTopology(anyLoading);\n                    requestedTopology.error = error;\n                  });\n              },\n            );\n            // Save the request out of here in case we have to abort it further\n            currentRequests.current.push(request);\n          }\n        });\n      }, [requestedTopologies, pdbDataFile]);\n\n      // Set the pdbFile\n      const pdbFile = useMemo(() => {\n        const mainComponent = comps[0];\n        const mainTopology = topologies.find(topology => {\n          return topology.url === mainComponent.topologyURL;\n        });\n        const { file: pdbFile } = mainTopology || {\n          loading: false,\n          file: pdbDataFile,\n        };\n        return pdbFile;\n      }, [comps, topologies, pdbDataFile]);\n\n      // Download trajectories ------------------------------------------------------------------------------------------------\n\n      // First we find all trajectory URLs (i.e. all requests to API)\n      // Then we ask the API skipping repeated URLs\n\n      // Set a function to modify an url by adding the frames range according to requestedFramesNumber\n      // The only exception are those trajectories whose frame number is lower than requestedFramesNumber\n\n      // Set a state to store requested trajectories and their loading status\n      const [requestedTrajectories, setRequestedTrajectories] = useState([]);\n      // Set also a state to track whenever there is still a downloading trajectory\n      const [anyLoadingTrajectory, setAnyLoadingTrajectory] = useState(false);\n\n      // Find if there are new trajectories to be requested in the components:\n      // Collect trajectories on each component\n      // If the component has no trajectory specified use the main trajectory\n      // If the component is not the main component and has no frame specified, use the first frame\n      // Only the main component (the first) is allowed to load multiple frames by the moment\n      useMemo(() => {\n        // Send a request to the API with the url of the rgyr analysis\n        const { loading, payload, error } = fileDescriptors;\n        // If we do not have file descritors yet then stop here\n        if (loading) return;\n        // Throw it in case something went wrong with the donwload\n        else if (error) throw error;\n        else if (!payload) throw new Error('Something bad happened with file descriptors');\n        // Finally update the trajectories state\n        setRequestedTrajectories(currentTrajectories => {\n          // Save the new requetsed trajectories\n          const newTrajectories = [];\n\n          // Set the url to ask the API\n          // Here, if you ask for the trajectory.bin instead of just trajectory, you get the whole file\n          // This is because the only route of the API accepting frames selection is the \"trajectory\" endpoint\n          // Other paths such as \"trajectory.bin\" will be processed as \"/:files\"\n          const baseUrl = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/trajectory`;\n\n          comps.forEach((comp, c) => {\n            if (comp.onlyTopology) return;\n\n            // Set the first component as the 'principal' component\n            const isPrincipal = c === 0;\n            const requestedFrame = comp.frame;\n\n            // Get the trajectory urls\n            // If the component has no trajectory url specified then use the main trajectory url alone\n            let urls = comp.trajectoryURLs || [baseUrl];\n\n            // Add the frames number of all the component requested trajectories\n            comp.frameCount = 0;\n\n            urls.forEach((url, u) => {\n              // Check if the url is already framed\n              const framed = parseFrameRange(url);\n\n              // Get the name of the trajectory file inside the database\n              // i.e. the end of the requested URL\n              // The exception is the API endpoint 'trajectory', which uses the 'trajectory.bin' file\n              let trajectoryFilename = url.split('/').slice(-1)[0];\n              if (framed)\n                trajectoryFilename = trajectoryFilename.split('?frames=')[0];\n              if (trajectoryFilename === 'trajectory')\n                trajectoryFilename = 'trajectory.bin';\n\n              // Get the file descriptor of the required trajectory\n              const trajectoryFileDescriptor = payload.find(file => {\n                return file.filename === trajectoryFilename;\n              });\n              if (!trajectoryFileDescriptor)\n                throw new Error(\n                  `Trajectory \"${trajectoryFilename}\" is missing`,\n                );\n              const trajectoryMetadata = trajectoryFileDescriptor.metadata;\n\n              // Get the number of frames in the whole trajectory\n              const trajectoryFrames = trajectoryMetadata.frames;\n\n              // Set the number of frames to be requested from the whole trajectory\n              let requestedFrames = requestedFramesNumber;\n              if (requestedFramesNumber > trajectoryFrames)\n                requestedFrames = trajectoryFrames;\n              if (Number.isFinite(requestedFrame)) requestedFrames = 1;\n              else if (framed) requestedFrames = framed.frames;\n              // Components which are not the principal must include a 'frame' value\n              else if (!isPrincipal && trajectoryFrames > 1)\n                throw new Error(\n                  `Only the main component is allowed to load multiple frames`,\n                );\n\n              // Frames are added to any url which is missing the frames range according to requestedFramesNumber\n              // The only exception are those trajectories whose frame number is lower than requestedFramesNumber\n              let finalUrl = url;\n              // Get the expected number of frames returned, which may not be exactly the requested number\n              let returnedFrames;\n              // In case the url is already frammed\n              if (framed) {\n                // Find maximum number of frames to be returned (trajectory frames or requetsed frames)\n                const maximumFrames = Math.min(trajectoryFrames, framed.end);\n                returnedFrames = Math.ceil(maximumFrames / framed.step);\n              }\n              // Modify the url if it is not framed yet\n              else {\n                // Get the string frames range according to requestedFramesNumber\n                const { range: framesRange, frames: framesCount } = getFrames(\n                  trajectoryFrames,\n                  requestedFrames,\n                  requestedFrame,\n                );\n                returnedFrames = framesCount;\n\n                // Add the frames range to the original url\n                if (framesRange) finalUrl = url + `?frames=${framesRange}`;\n              }\n\n              // Set the component framed url if it doesn't exists\n              if (!comp.framedURLs) comp.framedURLs = [];\n\n              // Save this final url in the framedURL in the component\n              // Overwrite the previous framed url if exists\n              comp.framedURLs[u] = finalUrl;\n\n              // Add the requested frames number to the frame count\n              comp.frameCount += requestedFrames;\n\n              // Check if the requested url is already in the list\n              // If so, skip this request\n              // If not, save the request url and proceed\n              const current = currentTrajectories.find(trajectory => {\n                return trajectory.url === finalUrl;\n              });\n              if (!current) {\n                newTrajectories.push({\n                  url: finalUrl,\n                  frames: returnedFrames,\n                  // Add also the atoms number, which is used further\n                  atoms: trajectoryMetadata.atoms,\n                  loading: true,\n                  requested: false,\n                });\n                setAnyLoadingTrajectory(true);\n              }\n            });\n          });\n          // In case there are new requested trajectories we return a new array to trigger dependencies\n          if (newTrajectories.length > 0)\n            return [...currentTrajectories, ...newTrajectories];\n          // Otherwise we return the previous array to do no trigger dependencies\n          return currentTrajectories;\n        });\n      }, [accession, comps, fileDescriptors, requestedFramesNumber]);\n\n      // Set a state to store trajectories data\n      const [trajectories, setTrajectories] = useState([]);\n\n      // Set a function to update the current loading progress\n      const updateLoadingProgress = useCallback(() => {\n        const mainComp = comps[0];\n        // Get all trajectories to be used as the current main trajecotry\n        const mainTrajectories = [];\n        // Get the current trajectories state using a trick\n        // DANI: si intentas acceder a un state dentro de un callback te da el valor del state cuando se hizo el callback\n        // DANI: Absurdo, pero es así, y esta es la forma de sortear el problema\n        let trajectoriesState = [];\n        setTrajectories(current => {\n          trajectoriesState = current;\n          return current;\n        });\n        mainComp.framedURLs.forEach(url => {\n          const trajectory = trajectoriesState.find(trajectory => {\n            return trajectory.url === url;\n          });\n          if (trajectory) mainTrajectories.push(trajectory);\n        });\n        if (mainTrajectories.length === 0) return;\n        // Then calculate the average progress in all loading trajectories and update the progress state\n        const overallFrames = mainTrajectories\n          .map(trajectory => trajectory.frames)\n          .reduce((a, b) => a + b, 0);\n        const overallProgress =\n          mainTrajectories\n            .map(trajectory => trajectory.progress * trajectory.frames)\n            .reduce((a, b) => a + b, 0) / overallFrames;\n        onLoad(overallProgress);\n      }, [comps, setTrajectories, onLoad]);\n\n      // Download the requested trajectory data (frames)\n      useEffect(() => {\n        requestedTrajectories.forEach(trajectory => {\n          // Check if the trajectory has been requested already\n          // If so, skip this request\n          if (trajectory && trajectory.requested) return;\n          trajectory.requested = true;\n\n          // Set the loading status as true\n          trajectory.loading = true;\n          trajectory.progress = 0;\n\n          // Request the API\n          // http exception is added for local testing in http://localhost\n          const getter =\n            trajectory.url.substring(0, 5) === 'https' ? https.get : http.get;\n          const request = getter(url.parse(trajectory.url), response => {\n            const totalBytes = response.headers['content-length'];\n            // Set the new trajectory\n            setTrajectories(previousTrajectories => {\n              const newTrajectory = {\n                url: trajectory.url,\n                frames: trajectory.frames,\n                atoms: trajectory.atoms,\n                payload: new ArrayBuffer(0),\n                progress: 0,\n              };\n              return [...previousTrajectories, newTrajectory];\n            });\n            // Track the amout of bytes already downloaded\n            let byteCount = 0;\n            response\n              .on('data', chunk => {\n                byteCount += chunk.byteLength;\n                trajectory.progress = byteCount / totalBytes;\n                // Update trajectories with the current partial data we have\n                setTrajectories(previousTrajectories => {\n                  const currentTrajectory = previousTrajectories.find(\n                    t => t.url === trajectory.url,\n                  );\n                  currentTrajectory.payload = appendBuffer(\n                    currentTrajectory.payload,\n                    chunk,\n                  );\n                  currentTrajectory.progress = trajectory.progress;\n                  return [...previousTrajectories];\n                });\n                updateLoadingProgress();\n              })\n              .on('end', () => {\n                // Save the main data in the ref\n                trajectory.loading = false;\n                // Then check the loading state of all requested trajectories and update the overall loading state\n                const anyLoading = requestedTrajectories.some(\n                  trajectory => trajectory.loading,\n                );\n                setAnyLoadingTrajectory(anyLoading);\n              });\n          });\n          currentRequests.current.push(request);\n        });\n      }, [requestedTrajectories, updateLoadingProgress]);\n\n      // If the whole component is removed then abort all requests in case they were not finished\n      // Note that this includes both topology and trajectory requests\n      // DANI: No he verificado que esto funcione bien a nivel de API\n      useEffect(() => {\n        // I save it in a constant to avoid a non-sense warning\n        const redundantList = currentRequests.current;\n        return () => {\n          redundantList.forEach(request => {\n            request.abort();\n          });\n        };\n      }, []);\n\n      // Setup molstar\n      useEffect(() => {\n        // This wrapper function is the most correct way to call awaits inside a use effect\n        const wrap = async () => {\n          // Create the plugin\n          molstarRef.current = await createPluginUI(\n            parentRef.current,\n            molstarSpec,\n          );\n          // console.log(molstarRef.current)\n        };\n        wrap();\n        // Cleanup function\n        return () => {\n          if (molstarRef.current) {\n            molstarRef.current.dispose();\n            molstarRef.current = null;\n          }\n        };\n      }, []);\n\n      // Load topologies in molstar\n      useEffect(() => {\n        // Stop here if we are still loading topologies\n        if (anyLoadingTopology) return;\n        // Get the molstar reference\n        const molstar = molstarRef.current;\n        if (!molstar) return;\n        // Load each topology\n        topologies.forEach(async topology => {\n          // Download and apply data\n          const data = await molstar.builders.data.rawData(\n            { data: topology.file } /* replace with your URL */,\n            { state: { isGhost: true } },\n          );\n          // DANI: Aunque no llegues a 'aplicarla' acabas teniendo una trayectoria de una frame en la data\n          const trajectory = await molstar.builders.structure.parseTrajectory(\n            data,\n            'pdb',\n          );\n          // WARNING: Do not modify this model\n          // WARNING: Althought it should be the same model\n          const model = await molstar.builders.structure.createModel(\n            trajectory,\n          );\n\n          // DANI: Esta función te acepta igual una trayectory que un model que una structure\n          // await molstar.builders.structure.hierarchy.applyPreset(structure, \"default\");\n\n          // console.log(molstar);\n          // console.log(molstar.managers.structure.hierarchy.current);\n\n          // // Set the representations (https://github.com/molstar/molstar/issues/68)\n          // // WARNING: Default MolStar representation is not the most efficient one so we have to tweak it\n          // // First set the different features we may encounter within the structure\n          // const components = {\n          //     polymer: await molstar.builders.structure.tryCreateComponent(structure, 'polymer'),\n          //     ligand: await molstar.builders.structure.tryCreateComponent(structure, 'ligand'),\n          //     //water: await molstar.builders.structure.tryCreateComponent(structure, 'water'),\n          // };\n          // // Now\n          // const builder = molstar.builders.structure.representation;\n          // const update = molstar.build();\n          // if (components.polymer) builder.buildRepresentation(update, components.polymer, {\n          //   type: 'line',\n          //   //typeParams: { alpha: 0.51 } // Make it transparent\n          // }, { tag: 'polymer' });\n          // if (components.ligand) builder.buildRepresentation(update, components.ligand, {\n          //   type: 'ball-and-stick'\n          // }, { tag: 'ligand' });\n          // //if (components.water) builder.buildRepresentation(update, components.water, { type: 'ball-and-stick', typeParams: { alpha: 0.6 } }, { tag: 'water' });\n          // await update.commit();\n\n          // Save the model reference inside the molstar reference\n          molstar.modelRef = model.ref;\n        });\n      }, [anyLoadingTopology, topologies]);\n\n      // Load trajectories in molstar\n      // Once the trajectories are downloaded, load them in corresponding NGL representations\n      // Every time the trajectory payloads change this useEffect must be rerun\n      useEffect(() => {\n        // Get the molstar reference\n        const molstar = molstarRef.current;\n        if (!molstar) return;\n        // If there must be no trajectory then stop here\n        if (noTrajectory) return;\n        // This wrapper function is the most correct way to call awaits inside a use effect\n        const wrap = async () => {\n          // Check if trajectories are\n          if (!topologies || !trajectories || trajectories.length === 0) return;\n\n          // If molstar or the main model are not set yet then we must wait\n          if (!molstar || !molstar.modelRef) return;\n\n          const trajectory = trajectories[0];\n\n          let trajectoryAtoms;\n          let trajectoryFinalExpectedFrames = 0;\n\n          trajectoryAtoms = trajectory.atoms;\n          if (trajectoryAtoms !== trajectory.atoms)\n            throw new Error(\n              `Atoms number in the different trajectories do not match`,\n            );\n\n          // Add the final expected frames for all frames in the component\n          trajectoryFinalExpectedFrames += trajectory.frames;\n\n          const payload = trajectory.payload;\n          const bytesPerFrame = trajectoryAtoms * BYTES_PER_ATOM;\n          const fitLength =\n            Math.floor(payload.byteLength / bytesPerFrame) * bytesPerFrame;\n          const totalPayload = payload.slice(0, fitLength);\n\n          // If the total payload is empty then stop here\n          if (totalPayload.byteLength === 0) return;\n\n          // Calculate how many frames are there in total\n          const totalFrames = totalPayload.byteLength / bytesPerFrame;\n          const lastFrameIndex = totalFrames - 1;\n\n          // Check if all required data is already downloaded\n          const completedTrajectory =\n            totalFrames === trajectoryFinalExpectedFrames;\n          if (!completedTrajectory) return;\n\n          // Load coordinates as they are parsed\n          const coords = await molstar\n            .build()\n            .toRoot()\n            .apply(TrajectoryFromCustomData, {\n              data: totalPayload,\n              natoms: trajectory.atoms,\n            })\n            .commit();\n\n          // Get the current loaded trajectories\n          // DANI: No te fies de este número\n          // DANI: Aquí aparecen todas las trayectorias declaradas, incluido aquellas que no han sido 'aplicadas'\n          const loadedTrajectories =\n            molstar.managers.structure.hierarchy.current.trajectories;\n\n          const molstarTrajectory = await molstar\n            .build()\n            .toRoot()\n            .apply(\n              TrajectoryFromModelAndCoordinates,\n              {\n                modelRef: molstar.modelRef,\n                coordinatesRef: coords.ref,\n              },\n              { dependsOn: [molstar.modelRef, coords.ref] },\n            )\n            .commit();\n\n          // Get the current trajectory model\n          // From now on, this is the model to be modified and not the model in molstar.modelRef\n          const newModel = await molstar.builders.structure.createModel(\n            molstarTrajectory,\n          );\n\n          // Set the default representation\n          // Use a lightweighted representation type\n          const structure = await molstar.builders.structure.createStructure(\n            newModel,\n          );\n          const components = molstar.build().to(structure);\n          const lightRepresentation = createStructureRepresentationParams(\n            molstar,\n            void 0,\n            {\n              type: 'cartoon',\n              typeParams: {\n                // Quality options: custom, auto, highest, higher, high, medium, low, lower, lowest\n                // https://github.com/molstar/molstar/blob/0e197b18857d59c27f51d4aa0226cd772bc872ca/src/mol-geo/geometry/base.ts\n                // DANI: 'lowest' se ve muy feo y no mejora mucho el rendimiento\n                quality: 'lower',\n                ignoreHydrogens: 'all',\n                ignoreHydrogensVariant: 'all',\n                ignoreLight: true,\n              },\n            },\n          );\n\n          components.apply(\n            StateTransforms.Representation.StructureRepresentation3D,\n            lightRepresentation,\n          );\n          await components.commit();\n\n          // DANI: Hay 2 presets: 'default' y 'all-models'. Aparecen siempre, aunque tu no los hayas creado\n          //const currentPresets = molstar.builders.structure.hierarchy.getPresetsWithOptions(molstarTrajectory);\n          //console.log(currentPresets);\n\n          // DANI: El apply preset puede hacerse a 'default' o a 'all-models'\n          // DANI: El 'all-models' te representa todas las frames superpuestas (y tarda)\n          // await molstar.builders.structure.hierarchy.applyPreset(\n          //   molstarTrajectory,\n          //   'default',\n          // );\n\n          // If there is a trajectory already update it with new data\n          if (loadedTrajectories.length > 0) {\n            //if (loadedTrajectories.length > 1) throw new Error('Molstar error: There should be only 1 trajectory');\n            //console.log('already loaded traj!!');\n          }\n          // If there is not trajectory yet then create a new trajectory\n          else {\n            //console.log('loading for the first time');\n          }\n        };\n        wrap();\n      }, [topologies, trajectories, comps, noTrajectory]);\n\n      // play/pause button effect\n      useEffect(() => {\n        // Get molstar\n        // If it has not been yet initiated then stop here\n        const molstar = molstarRef.current;\n        if (!molstar) return;\n\n        // If there is no trajectory then there is nothing to play\n        if (noTrajectory) return;\n\n        // Play\n        if (playing && isInView) {\n          molstar.managers.animation.play(AnimateModelIndex, {\n            // Select the time it takes to switch between frames\n            //duration: { name: 'fixed', params: { durationInS: 10 } },\n            //duration: { name: 'computed', params: { targetFps: 10 } },\n            duration: { name: 'sequential', params: { maxFps: 10 } },\n            // Select the mode it switches frames\n            //mode: { name: 'once', params: { direction: 'forward' } }\n            mode: { name: 'loop', params: { direction: 'forward' } },\n            //mode: { name: 'palindrome', params: {} }\n          });\n        }\n        // Pause\n        else {\n          molstar.managers.animation.stop();\n        }\n      }, [playing, isInView, noTrajectory, bounce]);\n\n      // Resize logic\n      // declare handler\n      const handleResize = useCallback(async () => {\n        if (!stageRef.current) return;\n        const canvas = containerRef.current.querySelector('canvas');\n        if (canvas) {\n          canvas.style.height = '';\n          canvas.style.cursor = 'default';\n        }\n        // WARNING: This sleep here is to fix a bug\n        // When we open/close settings we trigger this function but it takes the size of the window before changing\n        // The sleep fixes this problem altought the delay is 0\n        await sleep(0);\n        stageRef.current.handleResize();\n      }, []);\n      // connect the handle to events\n      useEffect(() => {\n        window.addEventListener('resize', handleResize);\n        return () => {\n          window.removeEventListener('resize', handleResize);\n        };\n      }, [handleResize]);\n\n      // Expose public methods and getters/setters\n      useImperativeHandle(\n        ref,\n        () => ({\n          autoResize: handleResize,\n          // Output the current orientation/focus in console\n          // Note: this is for the developer, not for the regular user\n          displayFocus() {\n            const orientation = stageRef.current.viewerControls.getOrientation();\n            const stringifiedArray = `[${orientation.elements.toString()}]`;\n            console.log(stringifiedArray);\n          },\n          centerFocus() {\n            setFocus({ comp: 0, sele: 'all' });\n            // Use the provided orientation, if any\n            // DANI: Sin hacer\n          },\n          get currentFrame() {\n            if (!(isFirstCompStaged && requestedTrajectories.length)) return -1;\n            try {\n              return stageRef.current.compList[0].trajList[0].trajectory\n                .currentFrame;\n            } catch (_) {\n              return -1;\n            }\n          },\n          set currentFrame(value) {\n            if (!(isFirstCompStaged && requestedTrajectories.length)) return;\n            try {\n              const total = this.totalFrames;\n              let frame = value;\n              if (frame < 0) frame = 0;\n              if (frame >= total) frame = total - 1;\n              stageRef.current.compList[0].trajList[0].trajectory.setFrame(\n                frame,\n              );\n            } catch (_) {\n              /* */\n            }\n          },\n          get totalFrames() {\n            if (!(isFirstCompStaged && requestedTrajectories.length)) return 1;\n            try {\n              return stageRef.current.compList[0].trajList[0].trajectory.frames\n                .length;\n            } catch (_) {\n              return 1;\n            }\n          },\n          get totalExpectedFrames() {\n            try {\n              return stageRef.current.compList[0].trajList[0].expectedFrames;\n            } catch (_) {\n              return 1;\n            }\n          },\n        }),\n        [isFirstCompStaged, requestedTrajectories, handleResize],\n      );\n\n      // workaround to have multiple ref logic on one element\n      // https://github.com/thebuilder/react-intersection-observer/issues/186#issuecomment-468641525\n      const handleRef = node => {\n        inViewRef(node);\n        parentRef.current = node;\n      };\n\n      // Finally, render the ngl window\n      return (\n        <>\n          <div\n            ref={handleRef}\n            className={cn(className, style.container, {\n              [style['loading-structure']]: anyLoadingTopology,\n              [style['loading-trajectory']]:\n                !noTrajectory && anyLoadingTrajectory,\n              [style['light-theme']]: !darkBackground,\n            })}\n            // Display loading status data in the upper left corner of the NGL window\n            data-loading={undefined}\n          />\n          <div ref={tooltipRef} className={style.tooltip}>\n            {tooltipContent}\n          </div>\n        </>\n      );\n    },\n  ),\n);\n\nexport default MolstarViewer;\n","import { Frames } from 'ngl';\n\n// Set the number of bytes per element in trajectory data\nconst BYTES_PER_COORDINATE = 4; // float 32\nconst COORDINATES_PER_ATOM = 3; // x, y and z\nconst BYTES_PER_ATOM = BYTES_PER_COORDINATE * COORDINATES_PER_ATOM;\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into NGL formatted coordinates\nconst payloadToNGLCoordinates = (\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n) => {\n  // Parse binary to coordinates\n  const trajectoryCoordinates = new Float32Array(trajectoryData);\n  try {\n    // Save all coordinates here\n    // This array is to be returned at the end\n    const overallCoordinates = [];\n    for (let i = 0; i < trajectoryFrames; i++) {\n      // Create a new array with the length of the number of atoms in the pdbFile * 3\n      const coordinates = new Float32Array(\n        trajectoryAtoms * COORDINATES_PER_ATOM,\n      );\n      coordinates.set(\n        trajectoryCoordinates.subarray(\n          i * trajectoryAtoms * COORDINATES_PER_ATOM,\n          (i + 1) * trajectoryAtoms * COORDINATES_PER_ATOM,\n        ),\n      );\n      // Push the new coordinates each frame\n      overallCoordinates.push(coordinates);\n    }\n    return overallCoordinates;\n  } catch (error) {\n    // If this fails the topology may not match the trajectory in atom number\n    return null;\n  }\n};\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into NGL formatted coordinates\n// This alternative function is used when the trajectory has less atoms than the structure\n// This may happen when trajectory data contains only heavy or backbone atoms (e.g. pca projections)\nconst payloadToNGLCoordinatesFiltered = (\n  atomCount,\n  atomIndices,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n) => {\n  // Parse binary to coordinates\n  const trajectoryCoordinates = new Float32Array(trajectoryData);\n  // Check atom number to be as expected\n  const expectedAtomNumber =\n    trajectoryCoordinates.length / COORDINATES_PER_ATOM / trajectoryFrames;\n  if (expectedAtomNumber !== trajectoryAtoms) {\n    console.log('Number of coordinates: ' + trajectoryCoordinates.length);\n    console.log('Number of frames: ' + trajectoryFrames);\n    console.log('Expected number of atoms: ' + expectedAtomNumber);\n    console.log('Actual number of atoms: ' + trajectoryAtoms);\n    throw new Error(`Trajectory atom number is wrong`);\n  }\n\n  try {\n    // Save all coordinates here\n    // This array is to be returned at the end\n    const overallCoordinates = [];\n    for (let i = 0; i < trajectoryFrames; i++) {\n      // Create a new array with the length of the number of atoms in the structure * 3\n      const coordinates = new Float32Array(atomCount * COORDINATES_PER_ATOM);\n      let k = 0;\n      // Create our own trajectory with coordinates only for the specified atoms\n      // The coordinates of the excluded atoms are set to 0\n      // This makes the trajectory compatible with the structure\n      for (let j = 0; j < atomCount; j++) {\n        //if (k >= trajectoryAtoms) break;\n        if (atomIndices.indexOf(j) !== -1) {\n          coordinates[j * COORDINATES_PER_ATOM] =\n            trajectoryCoordinates[\n              i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                k * COORDINATES_PER_ATOM\n            ];\n          coordinates[j * COORDINATES_PER_ATOM + 1] =\n            trajectoryCoordinates[\n              i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                k * COORDINATES_PER_ATOM +\n                1\n            ];\n          coordinates[j * COORDINATES_PER_ATOM + 2] =\n            trajectoryCoordinates[\n              i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                k * COORDINATES_PER_ATOM +\n                2\n            ];\n          k++;\n        }\n      }\n      // Push the new coordinates each frame\n      overallCoordinates.push(coordinates);\n    }\n    return overallCoordinates;\n  } catch (e) {\n    // If this fails the topology may not match the trajectory in atom number\n    return null;\n  }\n};\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into NGL formatted coordinates\n// This alternative function is used when the trajectory has less atoms than the structure\n// This may happen when trajectory data contains only heavy or backbone atoms (e.g. pca projections)\nconst payloadToNGLCoordinatesAlternative = (\n  pdbFile,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n) => {\n  // Parse binary to coordinates\n  const trajectoryCoordinates = new Float32Array(trajectoryData);\n  // Check atom number to be as expected\n  if (\n    trajectoryCoordinates.length / COORDINATES_PER_ATOM / trajectoryFrames !==\n    trajectoryAtoms\n  )\n    throw new Error(`Trajectory atom number is wrong`);\n\n  let format = '';\n\n  // Then count different combinations of atoms in the pdbFile\n  let k = 0;\n  let backboneAtoms = 0;\n  let heavyAtoms = 0;\n  for (let a = 0; a < pdbFile.atomCount; a++) {\n    // DANI: He probado a quitar esta condición. hay que probar que funcione bien en la vieja model\n    // DANI: En las trayectorias del Shaw el 'isProtein' no funcionaba y devolvía siempre 'false'\n    //if (!pdbFile.getAtomProxy(a).isProtein()) break;\n    if (k >= trajectoryAtoms) break;\n    if (\n      pdbFile.getAtomProxy(a).atomname === 'C' ||\n      pdbFile.getAtomProxy(a).atomname === 'CA' ||\n      pdbFile.getAtomProxy(a).atomname === 'N'\n    ) {\n      backboneAtoms += 1;\n    }\n    if (pdbFile.getAtomProxy(a).element !== 'H') {\n      heavyAtoms += 1;\n    }\n  }\n  // Finally check which count matches the expected number of atoms\n  if (trajectoryAtoms === backboneAtoms) format = 'backbone';\n  else if (trajectoryAtoms === heavyAtoms) format = 'heavy';\n  else\n    console.error(\n      `Number of atoms does not match any defined atoms selection\n      Number of atoms: ${trajectoryAtoms}\n      Expected backbone atoms: ${backboneAtoms}\n      Expected heavy atoms: ${heavyAtoms}`,\n    );\n  try {\n    // Save all coordinates here\n    // This array is to be returned at the end\n    const overallCoordinates = [];\n    for (let i = 0; i < trajectoryFrames; i++) {\n      // Create a new array with the length of the number of atoms in the pdbFile * 3\n      const coordinates = new Float32Array(\n        pdbFile.atomCount * COORDINATES_PER_ATOM,\n      );\n      let k = 0;\n      // Create our own trajectory with coordinates only for the specified atoms\n      // The coordinates of the excluded atoms are set to 0\n      // This makes the trajectory compatible with the pdbFile\n      if (format === 'backbone') {\n        for (let j = 0; j < pdbFile.atomCount; j++) {\n          if (k >= trajectoryAtoms) break;\n          if (\n            pdbFile.getAtomProxy(j).atomname === 'C' ||\n            pdbFile.getAtomProxy(j).atomname === 'CA' ||\n            pdbFile.getAtomProxy(j).atomname === 'N'\n          ) {\n            coordinates[j * COORDINATES_PER_ATOM] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 1] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  1\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 2] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  2\n              ];\n            k++;\n          }\n        }\n      }\n      if (format === 'heavy') {\n        for (let j = 0; j < pdbFile.atomCount; j++) {\n          if (k >= trajectoryAtoms) break;\n          if (pdbFile.getAtomProxy(j).element !== 'H') {\n            coordinates[j * COORDINATES_PER_ATOM] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 1] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  1\n              ];\n            coordinates[j * COORDINATES_PER_ATOM + 2] =\n              trajectoryCoordinates[\n                i * trajectoryAtoms * COORDINATES_PER_ATOM +\n                  k * COORDINATES_PER_ATOM +\n                  2\n              ];\n            k++;\n          }\n        }\n      }\n      // Push the new coordinates each frame\n      overallCoordinates.push(coordinates);\n    }\n    return overallCoordinates;\n  } catch (e) {\n    // If this fails the topology may not match the trajectory in atom number\n    return null;\n  }\n};\n\n// This converts the trajectory payload (i.e. atom coordinates in raw binary data) into an NGL object\n// This object can be further added to a NGL stage component\nexport const setNGLFile = (\n  topology,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n  atomIndices,\n) => {\n  if (!(topology && trajectoryData)) return;\n\n  let coordinates;\n  // In case topology and trajectory atoms match go for the canonical parsing\n  if (trajectoryAtoms === topology.atomCount)\n    coordinates = payloadToNGLCoordinates(\n      trajectoryData,\n      trajectoryAtoms,\n      trajectoryFrames,\n    );\n  else if (atomIndices)\n    coordinates = payloadToNGLCoordinatesFiltered(\n      topology.atomCount,\n      atomIndices,\n      trajectoryData,\n      trajectoryAtoms,\n      trajectoryFrames,\n    );\n  // Otherwise it may mean the trajectory has only heavy/backbone atoms\n  // Then parse it taking this in count\n  // DANI: Esto es más un arreglo que no algo permanente\n  // DANI: Lo suyo sería que en estos casos se pida la estructura solo con los átomos que hacen falta\n  else\n    coordinates = payloadToNGLCoordinatesAlternative(\n      topology,\n      trajectoryData,\n      trajectoryAtoms,\n      trajectoryFrames,\n    );\n\n  // If we do not have coordinates at this point it may mean the topology and trajectory are not matching in atom number\n  if (!coordinates)\n    throw new Error(`Topology and trajectory data may not match`);\n\n  // Finally build the NGL object and add the parsed coordinates\n  const file = new Frames('Dynamically generated trajectory', '');\n  file.coordinates = coordinates;\n  return file;\n};\n\n// This updates an already set NGL object by adding new trajectory data\nexport const updateNGLFile = (\n  file,\n  topology,\n  trajectoryData,\n  trajectoryAtoms,\n  trajectoryFrames,\n  atomIndices,\n) => {\n  if (!(file && topology && trajectoryData)) return;\n\n  // The NGL file may already have trajectory data\n  // There is no need to process those coordinates again, so they must discarded from the parsing\n\n  // Find out how many frames are already loaded\n  const currentFrames = file.frames.length;\n\n  // If there are as many frames already as the new trajectory frames then we have nothing to do\n  if (currentFrames >= trajectoryFrames) return;\n\n  // Calculate how many bytes we must discard and discard them from the begining of the array buffer\n  const discardBytes = currentFrames * trajectoryAtoms * BYTES_PER_ATOM;\n  const newTrajectoryData = trajectoryData.slice(discardBytes);\n  const newTrajectoryFrames = trajectoryFrames - currentFrames;\n\n  let coordinates;\n  // In case topology and trajectory atoms match go for the canonical parsing\n  if (trajectoryAtoms === topology.atomCount)\n    coordinates = payloadToNGLCoordinates(\n      newTrajectoryData,\n      trajectoryAtoms,\n      newTrajectoryFrames,\n    );\n  else if (atomIndices)\n    coordinates = payloadToNGLCoordinatesFiltered(\n      topology.atomCount,\n      atomIndices,\n      newTrajectoryData,\n      trajectoryAtoms,\n      newTrajectoryFrames,\n    );\n  // Otherwise it may mean the trajectory has only heavy/backbone atoms\n  // Then parse it taking this in count\n  // DANI: Esto es más un arreglo que no algo permanente\n  // DANI: Lo suyo sería que en estos casos se pida la estructura solo con los átomos que hacen falta\n  else\n    coordinates = payloadToNGLCoordinatesAlternative(\n      topology,\n      newTrajectoryData,\n      trajectoryAtoms,\n      newTrajectoryFrames,\n    );\n\n  // If we do not have coordinates at this point it may mean the topology and trajectory are not matching in atom number\n  if (!coordinates)\n    throw new Error(`Topology and trajectory data may not match`);\n\n  // Finally update the NGL file coordinates\n  file.frames = file.frames.concat(coordinates);\n};\n","// This function expects to receive a specific frame or the number of frames to load\n// This function returns a string which specifies the frames to be loaded\n// This string is standarized in a API friendly format\nconst getFrames = (trajectoryFrames, requestedFrames, requestedFrame) => {\n  // only one specific frame loaded, as a projection\n  if (requestedFrame) {\n    return { range: (requestedFrame + 1).toString(), frames: 1 };\n  }\n  // multiple frames loaded, as a trajectory\n  else {\n    if (!trajectoryFrames)\n      throw new Error('Missing number of frames in the trajectory');\n    if (!requestedFrames) throw new Error('Missing number of requested frames');\n    const frameStep = Math.floor(trajectoryFrames / requestedFrames);\n    // Predict how many frames will be returned, which may be different from the requested frames number\n    const returnedFrames = Math.ceil(trajectoryFrames / frameStep);\n    return {\n      range: `${1}:${trajectoryFrames}:${frameStep}`,\n      frames: returnedFrames,\n    };\n  }\n};\n\nexport default getFrames;\n","// extracted by mini-css-extract-plugin\nexport default {\"container\":\"style_container__7Ceta\",\"light-theme\":\"style_light-theme__H4DPh\",\"loading-trajectory\":\"style_loading-trajectory__2DP4d\",\"loading-structure\":\"style_loading-structure__E1dyl\",\"tooltip\":\"style_tooltip__eJTpx\"};","import React, {\n  forwardRef,\n  memo,\n  useState,\n  useRef,\n  useImperativeHandle,\n  useCallback,\n  useMemo,\n  useEffect,\n  useContext,\n} from 'react';\n//import useToggleState from '../../hooks/use-toggle-state';\nimport { useInView } from 'react-intersection-observer';\nimport { clamp } from 'lodash-es';\nimport cn from 'classnames';\nimport { autoLoad, Stage, ColormakerRegistry, Matrix4 } from 'ngl';\n\nimport { frame } from 'timing-functions';\n\nimport { setNGLFile, updateNGLFile } from './payload-to-ngl-file';\nimport getFrames from './get-frames';\n\nimport { ProjectCtx, PdbCtx } from '../../contexts';\n\nimport { setTooltipPosition } from '../../utils/tooltip-position-manager';\n\nimport style from './style.module.css';\n\n// To get frames\nimport { BASE_PATH_PROJECTS } from '../../utils/constants';\n\n// Make a deep copy of an object even with cyclic references\nimport { cloneDeep } from 'lodash-es';\n\n// Used to just wait\nimport { sleep } from 'timing-functions';\n\nimport https from 'https-browserify';\nimport http from 'stream-http';\nimport { parse as urlParse } from 'url';\n\nconst DEFAULT_NUMBER_OF_FRAMES = 25;\nconst DEFAULT_ORIENTATION_TRANSITION_DURATION = 750; // 750 ms\n\nconst CHAIN_SELECTION = 'polymer and not hydrogen ';\n\nconst isValidColor = colorName => {\n  var s = new Option().style;\n  s.color = colorName;\n  return s.color === colorName;\n};\n\nconst frameRangeFormat = /\\?frames=(?<start>\\d+):(?<end>\\d+)(:(?<step>\\d+))?/;\nconst parseFrameRange = frameRange => {\n  // Search in the function's parameter value \"string\" by using a specified regexp format: STEP_FORMAT\n  const parsed = frameRangeFormat.exec(frameRange);\n  if (!parsed) return null;\n  // The 'frameRangeFormat' has 3 defined groups: start, end and step\n  // Use the value from the 3 groups to define and save the desired frames\n  const start = +parsed.groups.start;\n  const end = Math.max(+parsed.groups.end, start); // If the end is less than the start then just use the start\n  const step = +(parsed.groups.step || 1);\n  const frames = Math.floor((end - start) / step) + 1;\n  return { start, end, step, frames };\n};\n\n// Join 2 ArrayBuffer\n// https://stackoverflow.com/questions/10786128/appending-arraybuffers\nfunction appendBuffer(buffer1, buffer2) {\n  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\n// Set the number of bytes per element in trajectory data\nconst BYTES_PER_COORDINATE = 4; // float 32\nconst COORDINATES_PER_ATOM = 3; // x, y and z\nconst BYTES_PER_ATOM = BYTES_PER_COORDINATE * COORDINATES_PER_ATOM;\n\n// Set the NGL player speed limits\n// The actual 'currentSpeed' input limits are 0-100\n// The speed set as the time to wait before moving to the next frame in miliseconds\nconst minimumSpeed = 0;\nconst maximumSpeed = 100;\nconst slowestTimeout = 1000;\nconst fastestTimeout = 50;\nconst interpolateSpeed = currentSpeed => {\n  return (\n    slowestTimeout +\n    (currentSpeed - minimumSpeed) *\n      ((fastestTimeout - slowestTimeout) / (maximumSpeed - minimumSpeed))\n  );\n};\n\nconst defaultHighlightTypes = {\n  atoms: 'spacefill',\n  residues: 'ball+stick',\n  chains: 'ball+stick',\n  selections: 'ball+stick',\n};\n\nconst NGLViewer = memo(\n  forwardRef(\n    (\n      {\n        className,\n        playing,\n        spinning,\n        smooth,\n        onProgress,\n        onLoad,\n        bounce = false, // Set if the animation, when finished, starts again (false) or goes back (true)\n        requestedFramesNumber = DEFAULT_NUMBER_OF_FRAMES, // The number of frames to be represented\n        selectedAtoms, // Atom index of the atom and residue to be represented\n        selectedResidueIndices, // Residue indices from residues to be highlighted\n        selectedChains, // Chain letters from chains to be represented\n        selectedCustom, // Free NGL selections to be directly represented\n        selectedDistances, // Groups of 2 atoms or residues to be represented as a distance\n        selectedAngles, // Groups of 3 atoms to be represented as an angle\n        selectedRepresentation, // String name of a representation to be painted in yellow color (only 1)\n        snapRepresentations,\n        noTrajectory, // True when only specific frames must be loaded\n        initialFocus, // The ngl selection to be focused by the camera initially\n        darkBackground,\n        perspective,\n        speed,\n        // Final components and representations prepared for the viewer\n        components,\n        representations,\n        // Set the highlight representations types\n        highlightTypes = defaultHighlightTypes,\n      },\n      ref,\n    ) => {\n\n      // If no URL is provided then use the main trajectory // URL to find the trajectory data in the API\n      // True when we just want to display a static structure // Requeste number of frames to display\n      // data from context\n      const {\n        accession,\n        accessionAndMdNumber,\n        fileDescriptors,\n        curatedOrientation,\n        topology: topologyManager,\n      } = useContext(ProjectCtx);\n      const { file: pdbDataFile } = useContext(PdbCtx);\n\n      const [isFirstCompStaged, setIsFirstCompStaged] = useState(false);\n      const [isMainTrajectoryStaged, setIsMainTrajectoryStaged] = useState(false);\n      // The last automatic camera focus\n      const [focus, setFocus] = useState(initialFocus);\n\n      useMemo(() => {\n        //console.log(initialFocus);\n        setFocus(initialFocus);\n      }, [initialFocus]);\n\n      // references\n      const containerRef = useRef(null);\n      const stageRef = useRef(null);\n      const tooltipRef = useRef(null);\n      const firstTime = useRef(true);\n      // curatedOrientation might be null\n      const originalOritentationRef = useRef(\n        curatedOrientation ? new Matrix4().set(...curatedOrientation) : null,\n      );\n\n      // in-view hook\n      const [inViewRef, isInView] = useInView();\n\n      // Set the content of the tooltip in JSX format\n      const [tooltipContent, setTooltipContent] = useState(null);\n\n      // Download topologies ----------------------------------------------------------------------\n\n      // Download all requested topologies: Each component may have a different structure URL.\n      // Set the first component topology as the 'pdbData'\n      // If a topologyURL is provided, download data form the API\n      // Otherwise, use the main structure\n\n      // Set a state to store the topology requests\n      const [requestedTopologies, setRequestedTopologies] = useState([]);\n      // Set also a state to track whenever there is still a downloading topology\n      const [anyLoadingTopology, setAnyLoadingTopology] = useState(false);\n\n      // Find if there are new topology to be requested in the components:\n      // Collect the topology on each component\n      // If the component has no topology specified use the main topology\n      useMemo(() => {\n        setRequestedTopologies(previousRequestedTopologies => {\n          const newRequestedTopologies = [];\n          components.forEach(comp => {\n            const url = comp.topologyURL || null;\n            const selection = comp.atomSelection || null;\n            // Check if the url is new\n            // Else, skip this url since it has been requested already\n            const allRequestedTopologies = [\n              ...previousRequestedTopologies,\n              ...newRequestedTopologies,\n            ];\n            const current = allRequestedTopologies.find(topology => {\n              return topology.url === url;\n            });\n            if (current) return;\n            // Some urls may be missing\n            // This happens when the component wants the default topology from the pdbData\n            if (url === null) {\n              // Add a request with null url in order to get pdbData as a topology\n              // Do it only once for all components\n              newRequestedTopologies.push({\n                url: null,\n                loading: false,\n                error: null,\n              });\n            } else {\n              // Add the topology to the list, so it will be requested to the API\n              newRequestedTopologies.push({\n                url: url,\n                selection: selection,\n                loading: true,\n                requested: false,\n                error: null,\n              });\n              setAnyLoadingTopology(true);\n            }\n          });\n          return [...previousRequestedTopologies, ...newRequestedTopologies];\n        });\n      }, [components, setRequestedTopologies]);\n\n      // Set a state to store the downloaded topologies\n      const [topologies, setTopologies] = useState([]);\n\n      // Keep track of all requests in case we have to abort them further\n      const currentRequests = useRef([]);\n\n      // Download all requested topologies/structures from the API\n      useEffect(() => {\n        requestedTopologies.forEach(requestedTopology => {\n          // Check if the requested url has the data already downloaded\n          // If so, skip this request\n          if (requestedTopology.file) return;\n          // If the topology failed to load do not try it again\n          if (requestedTopology.error) return;\n          // If the topology has been already requested do not request it again\n          if (requestedTopology.requested) return;\n          // Get the topology URL\n          const url = requestedTopology.url;\n          // If there is no URL load the context pdbData\n          if (url === null) {\n            // WARNING: The '[...previous]' is essential to make the array object change\n            // This is important, since the 'topologies' object is used as a dependency further\n            // And if we do not change the array then the change is not detected\n            setTopologies(previous => {\n              requestedTopology.loading = false;\n              // Then check the loading state of all requested topologies and update the overall loading state\n              const anyLoading = requestedTopologies.some(t => t.loading);\n              setAnyLoadingTopology(anyLoading);\n              // The topology with the pdb data has not url\n              const topology = { url: null, file: pdbDataFile };\n              return [...previous, topology];\n            });\n          }\n          // If there is an URL\n          else {\n            requestedTopology.requested = true;\n            // Create the POST body\n            const postData = JSON.stringify({\n              selection : requestedTopology.selection\n            });\n            // Request the API\n            // http exception is added for local testing in http://localhost\n            const protocol = url.substring(0, 5) === 'https' ? https : http;\n            const requestOptions = urlParse(url);\n            // We use the POST method instead of the regular GET method to allow long atom selections when requesting structure\n            // However, if we are requesting a file the POST method is not supported\n            const isStructureEndpoint = requestOptions.path.endsWith('/structure')\n            requestOptions.method = isStructureEndpoint ? 'POST' : 'GET';\n            requestOptions.headers = {\n              'Content-Type': 'application/json',\n              'Content-Length': postData.length\n            }\n            const request = protocol.request(requestOptions, response => {\n              // Track the amout of bytes already downloaded\n              let responseContent = new ArrayBuffer(0);\n              response\n                .on('data', chunk => {\n                  responseContent = appendBuffer(responseContent, chunk);\n                })\n                .on('end', () => {\n                  const stringBlob = new Blob( [ responseContent ], { type: 'text/plain'} );\n                  autoLoad(stringBlob, { defaultRepresentation: false, ext: \"pdb\" })\n                    .then(file => {\n                      setTopologies(previous => {\n                        requestedTopology.loading = false;\n                        // Then check the loading state of all requested topologies and update the overall loading state\n                        const anyLoading = requestedTopologies.some(t => t.loading);\n                        setAnyLoadingTopology(anyLoading);\n                        const topology = { url: url, file: file };\n                        return [...previous, topology];\n                      })\n                    })\n                    .catch(error => {\n                      requestedTopology.loading = false;\n                      // Then check the loading state of all requested topologies and update the overall loading state\n                      const anyLoading = requestedTopologies.some(t => t.loading);\n                      setAnyLoadingTopology(anyLoading);\n                      requestedTopology.error = error;\n                    });                  \n                });\n            });\n            // Send the request data (POST method feature)\n            if (requestOptions.method === 'POST'){\n              request.write(postData);\n            }\n            // Close the request for it to actually start\n            // Note that this is required for the https.request altought it was not by https.get\n            request.end();\n            currentRequests.current.push(request);\n          }\n        });\n      }, [requestedTopologies, pdbDataFile]);\n\n      const mainComponent = components[0] || {};\n      const mainTopology = topologies.find(topology => {\n        return topology.url === mainComponent.topologyURL;\n      });\n      const { file: pdbFile } = mainTopology || {\n        loading: false,\n        file: pdbDataFile,\n      };\n\n      // Download trajectories ------------------------------------------------------------------------------------------------\n\n      // First we find all trajectory URLs (i.e. all requests to API)\n      // Then we ask the API skipping repeated URLs\n\n      // Set a function to modify an url by adding the frames range according to requestedFramesNumber\n      // The only exception are those trajectories whose frame number is lower than requestedFramesNumber\n\n      // Set a state to store requested trajectories and their loading status\n      const [requestedTrajectories, setRequestedTrajectories] = useState([]);\n      // Set also a state to track whenever there is still a downloading trajectory\n      const [anyLoadingTrajectory, setAnyLoadingTrajectory] = useState(false);\n\n      // Find if there are new trajectories to be requested in the components:\n      // Collect trajectories on each component\n      // If the component has no trajectory specified use the main trajectory\n      // If the component is not the main component and has no frame specified, use the first frame\n      // Only the main component (the first) is allowed to load multiple frames by the moment\n      useMemo(() => {\n        // Send a request to the API with the url of the rgyr analysis\n        const { loading, payload, error } = fileDescriptors;\n        // If we do not have file descritors yet then stop here\n        if (loading) return;\n        // Throw it in case something went wrong with the donwload\n        else if (error) throw error;\n        else if (!payload) throw new Error('Something bad happened with file descriptors');\n        // Finally update the trajectories state\n        setRequestedTrajectories(currentTrajectories => {\n          // Save the new requetsed trajectories\n          const newTrajectories = [];\n\n          // Set the url to ask the API\n          // Here, if you ask for the trajectory.bin instead of just trajectory, you get the whole file\n          // This is because the only route of the API accepting frames selection is the \"trajectory\" endpoint\n          // Other paths such as \"trajectory.bin\" will be processed as \"/:files\"\n          const baseUrl = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/trajectory`;\n\n          components.forEach((comp, c) => {\n            if (comp.onlyTopology) return;\n\n            // Set the first component as the 'principal' component\n            const isPrincipal = c === 0;\n            const requestedFrame = comp.frame;\n\n            // Get the trajectory urls\n            // If the component has no trajectory url specified then use the main trajectory url alone\n            let urls = comp.trajectoryURLs || [baseUrl];\n\n            // Add the frames number of all the component requested trajectories\n            comp.frameCount = 0;\n\n            urls.forEach((url, u) => {\n              // Check if the url is already framed\n              const framed = parseFrameRange(url);\n\n              // Get the name of the trajectory file inside the database\n              // i.e. the end of the requested URL\n              // The exception is the API endpoint 'trajectory', which uses the 'trajectory.bin' file\n              let trajectoryFilename = url.split('/').slice(-1)[0];\n              if (framed)\n                trajectoryFilename = trajectoryFilename.split('?frames=')[0];\n              if (trajectoryFilename === 'trajectory')\n                trajectoryFilename = 'trajectory.bin';\n\n              // Get the file descriptor of the required trajectory\n              const trajectoryFileDescriptor = payload.find(file => {\n                return file.filename === trajectoryFilename;\n              });\n              if (!trajectoryFileDescriptor)\n                throw new Error(\n                  `Trajectory \"${trajectoryFilename}\" is missing`,\n                );\n              const trajectoryMetadata = trajectoryFileDescriptor.metadata;\n\n              // Get the number of frames in the whole trajectory\n              const trajectoryFrames = trajectoryMetadata.frames;\n\n              // Set the number of frames to be requested from the whole trajectory\n              let requestedFrames = requestedFramesNumber;\n              if (requestedFramesNumber > trajectoryFrames)\n                requestedFrames = trajectoryFrames;\n              if (Number.isFinite(requestedFrame)) requestedFrames = 1;\n              else if (framed) requestedFrames = framed.frames;\n              // Components which are not the principal must include a 'frame' value\n              else if (!isPrincipal && trajectoryFrames > 1)\n                throw new Error(\n                  `Only the main component is allowed to load multiple frames`,\n                );\n\n              // Frames are added to any url which is missing the frames range according to requestedFramesNumber\n              // The only exception are those trajectories whose frame number is lower than requestedFramesNumber\n              let finalUrl = url;\n              // Get the expected number of frames returned, which may not be exactly the requested number\n              let returnedFrames;\n              // In case the url is already frammed\n              if (framed) {\n                // Find maximum number of frames to be returned (trajectory frames or requetsed frames)\n                const maximumFrames = Math.min(trajectoryFrames, framed.end);\n                returnedFrames = Math.ceil(maximumFrames / framed.step);\n              }\n              // Modify the url if it is not framed yet\n              else {\n                // Get the string frames range according to requestedFramesNumber\n                const { range: framesRange, frames: framesCount } = getFrames(\n                  trajectoryFrames,\n                  requestedFrames,\n                  requestedFrame,\n                );\n                returnedFrames = framesCount;\n\n                // Add the frames range to the original url\n                if (framesRange) finalUrl = url + `?frames=${framesRange}`;\n              }\n\n              // Set the component framed url if it doesn't exists\n              if (!comp.framedURLs) comp.framedURLs = [];\n\n              // Save this final url in the framedURL in the component\n              // Overwrite the previous framed url if exists\n              comp.framedURLs[u] = finalUrl;\n\n              // Add the requested frames number to the frame count\n              comp.frameCount += requestedFrames;\n\n              // Check if the requested url is already in the list\n              // If so, skip this request\n              // If not, save the request url and proceed\n              const current = currentTrajectories.find(trajectory => {\n                return trajectory.url === finalUrl;\n              });\n              if (!current) {\n                newTrajectories.push({\n                  url: finalUrl,\n                  frames: returnedFrames,\n                  // Add also the atoms number, which is used further\n                  atoms: trajectoryMetadata.atoms,\n                  loading: true,\n                  requested: false,\n                });\n                setAnyLoadingTrajectory(true);\n              }\n            });\n          });\n          // In case there are new requested trajectories we return a new array to trigger dependencies\n          if (newTrajectories.length > 0)\n            return [...currentTrajectories, ...newTrajectories];\n          // Otherwise we return the previous array to do no trigger dependencies\n          return currentTrajectories;\n        });\n      }, [accession, components, fileDescriptors, requestedFramesNumber]);\n\n      // Set a state to store trajectories data\n      const [trajectories, setTrajectories] = useState([]);\n\n      // Set a function to update the current loading progress\n      const updateLoadingProgress = useCallback(\n        currentTrajectories => {\n          const mainComp = components[0];\n          // Get all trajectories to be used as the current main trajecotry\n          const mainTrajectories = [];\n          mainComp.framedURLs.forEach(url => {\n            const trajectory = currentTrajectories.find(trajectory => trajectory.url === url);\n            if (trajectory) mainTrajectories.push(trajectory);\n          });\n          if (mainTrajectories.length === 0) return;\n          // Then calculate the average progress in all loading trajectories and update the progress state\n          const overallFrames = mainTrajectories\n            .map(trajectory => trajectory.frames)\n            .reduce((a, b) => a + b, 0);\n          const overallProgress =\n            mainTrajectories\n              .map(trajectory => trajectory.progress * trajectory.frames)\n              .reduce((a, b) => a + b, 0) / overallFrames;\n          onLoad(overallProgress);\n        }, [components, onLoad],\n      );\n\n      // Download the requested trajectory data (frames)\n      useEffect(() => {\n        requestedTrajectories.forEach(trajectory => {\n          // Check if the trajectory has been requested already\n          // If so, skip this request\n          if (trajectory && trajectory.requested) return;\n          trajectory.requested = true;\n\n          // Set the loading status as true\n          trajectory.loading = true;\n          trajectory.progress = 0;\n\n          // DANI: Todavía no me ha hecho falta hacer una selección larga de atomos/frames\n          // DANI: Todo está listo a nivel de API\n          // DANI: Solo hará falta reformar un poco el viewer-with-controls y este script\n          const postData = JSON.stringify({});\n\n          // Request the API\n          // http exception is added for local testing in http://localhost\n          const protocol = trajectory.url.substring(0, 5) === 'https' ? https : http;\n          const requestOptions = urlParse(trajectory.url);\n          // Check if the request points to the /trajectory endpoint or it is pointing to a file\n          const requestPathsteps = requestOptions.pathname.split('/')\n          const isTrajectoryEndpoint = requestPathsteps[requestPathsteps.length -1] === 'trajectory'\n          // We use the POST method instead of the regular GET method to allow long atom selections\n          // However, if we are retrieving a specific file the the POST method is not implemented\n          requestOptions.method = isTrajectoryEndpoint ? 'POST' : 'GET';\n          requestOptions.headers = {\n            'Content-Type': 'application/json',\n            'Content-Length': postData.length\n          }\n          const request = protocol.request(requestOptions, response => {\n            const totalBytes = response.headers['content-length'];\n            // Set the new trajectory\n            setTrajectories(previousTrajectories => {\n              const newTrajectory = {\n                url: trajectory.url,\n                frames: trajectory.frames,\n                atoms: trajectory.atoms,\n                payload: new ArrayBuffer(0),\n                progress: 0,\n              };\n              return [...previousTrajectories, newTrajectory];\n            });\n            // Track the amout of bytes already downloaded\n            let byteCount = 0;\n            response\n              .on('data', chunk => {\n                byteCount += chunk.byteLength;\n                trajectory.progress = byteCount / totalBytes;\n                // Update trajectories with the current partial data we have\n                setTrajectories(previousTrajectories => {\n                  const currentTrajectory = previousTrajectories.find(\n                    t => t.url === trajectory.url,\n                  );\n                  currentTrajectory.payload = appendBuffer(\n                    currentTrajectory.payload,\n                    chunk,\n                  );\n                  currentTrajectory.progress = trajectory.progress;\n                  // Update the current progess\n                  updateLoadingProgress(previousTrajectories);\n                  return [...previousTrajectories];\n                });\n              })\n              .on('end', () => {\n                // Save the main data in the ref\n                trajectory.loading = false;\n                // Then check the loading state of all requested trajectories and update the overall loading state\n                const anyLoading = requestedTrajectories.some(\n                  trajectory => trajectory.loading,\n                );\n                setAnyLoadingTrajectory(anyLoading);\n              });\n          });\n          // Send the request data (POST method feature)\n          if (requestOptions.method === 'POST'){\n            request.write(postData);\n          }\n          // Close the request for it to actually start\n          // Note that this is required for the https.request altought it was not by https.get\n          request.end();\n          currentRequests.current.push(request);\n        });\n      }, [requestedTrajectories, updateLoadingProgress]);\n\n      // If the whole component is removed then abort all requests in case they were not finished\n      // DANI: No he verificado que esto funcione bien a nivel de API\n      useEffect(() => {\n        // I save it in a constant to avoid a non-sense warning\n        const redundantList = currentRequests.current;\n        return () => {\n          redundantList.forEach(request => {\n            request.abort();\n          });\n        };\n      }, []);\n\n      // Set a state to keep track of the current working tasks in the viewer\n      // This is useful to update the upper left corner logs in the viewer\n      const [runningTasks, setRunningTasks] = useState(0);\n\n      // Update the running tasks count\n      const handleTasksChange = useCallback(\n        value => {\n          setRunningTasks(current => current + value);\n        },\n        [setRunningTasks],\n      );\n\n      // Stage creation and removal on mounting and unmounting\n      useEffect(() => {\n        // set-up\n        const stage = new Stage(containerRef.current);\n        // wait for a render to screen, then\n        frame().then(() => {\n          if (!stage) return;\n          // make sure NGL knows the size it has available\n          stage.handleResize();\n        });\n        // Set a signal function to handle the update of running tasks count\n        stage.tasks.signals.countChanged.add(handleTasksChange);\n        // Save the stage reference\n        stageRef.current = stage;\n        // clean-up\n        return () => {\n          // NOTE: following line causes to fail when loading a new viewer with\n          // NOTE: previous structure data\n          // stageRef.current.removeAllComponents();\n          stageRef.current.dispose();\n          stageRef.current = null;\n        };\n      }, []);\n\n      // Handle the upper left corner viewer logs\n      const viewerLogs = useMemo(() => {\n        if (!isFirstCompStaged) return `Loading structure`;\n        if (!pdbFile) return `No structure available`;\n        if (!requestedTrajectories.length && !noTrajectory)\n          return `No trajectory available`;\n        if (runningTasks > 0) return `Rendering...`;\n        return undefined; // Show nothing when everything was finished and fine\n      }, [\n        isFirstCompStaged,\n        pdbFile,\n        requestedTrajectories,\n        noTrajectory,\n        runningTasks,\n      ]);\n\n      // background (with transition)\n      useEffect(() => {\n        const beginning = Date.now();\n        let duration = 1000;\n        if (firstTime.current) {\n          duration = 0;\n          firstTime.current = false;\n        }\n        (async () => {\n          while (true) {\n            await frame(); // async, should check if we still have the viewer\n            if (!stageRef.current) return;\n            let currentTick = Date.now() - beginning;\n            // exit condition from 'while (true)' loop\n            // if we've gone over the full time of the animation\n            if (currentTick > duration) break;\n            if (darkBackground) currentTick = duration - currentTick;\n            const color = `#${Math.round((currentTick * 0xff) / duration)\n              .toString('16')\n              .padStart(2, '0')\n              .repeat(3)}`;\n            stageRef.current.viewer.setBackground(color);\n          }\n          await frame(); // async, should check if we still have the viewer\n          if (!stageRef.current) return;\n          // make sure we're set to the final colour\n          // (in case the transition was stopped halfway through)\n          stageRef.current.viewer.setBackground(\n            darkBackground ? 'black' : 'white',\n          );\n        })();\n        // set duration to 0 to cancel possibly ongoing loop\n        return () => (duration = 0);\n      }, [darkBackground]);\n\n      // perspective\n      useEffect(() => {\n        stageRef.current &&\n          stageRef.current.viewer &&\n          stageRef.current.viewer.setCamera &&\n          stageRef.current.viewer.setCamera(\n            perspective ? 'perspective' : 'orthographic',\n          );\n      }, [perspective]);\n\n      // frames\n      // Update the controls progress\n      useEffect(() => {\n        // Check if we are prepared to add the frame change handler and if t is required\n        if (!onProgress || noTrajectory || !isFirstCompStaged || !isMainTrajectoryStaged) return;\n        // Get the first component and check it exists\n        const firstComp = stageRef.current && stageRef.current.compList && stageRef.current.compList[0];\n        if (!firstComp) throw new Error('Something went wrong with the viewer first component');\n        // Get the first (and porbably only) trajectory handler and check it exists\n        const trajectoryHandler = firstComp.trajList && firstComp.trajList[0];\n        if (!trajectoryHandler) throw new Error('Something went wrong with the viewer trajectory handler');\n        // Get the frame count of the final number of frames (once the whole trajectory is loaded)\n        const frameCount = trajectoryHandler.expectedFrames;\n        // Set the actual function to handle frame change internally in the component\n        const frameHandler = frame => {\n          //console.log('NGL frameCount: ' + frameCount);\n          const progress = clamp(frame / (frameCount - 1), 0, 1);\n          onProgress(progress);\n        };\n        // Add the frame handler to the component signals\n        trajectoryHandler.signals.frameChanged.add(frameHandler);\n        // Set a cleanup function to remove the frame handler when there is need\n        return () => {\n          trajectoryHandler.signals.frameChanged.remove(frameHandler);\n        };\n      }, [isFirstCompStaged, isMainTrajectoryStaged, noTrajectory, onProgress]);\n\n      // Resize logic\n      // declare handler\n      const handleResize = useCallback(async () => {\n        if (!stageRef.current) return;\n        const canvas = containerRef.current.querySelector('canvas');\n        if (canvas) {\n          canvas.style.height = '';\n          canvas.style.cursor = 'default';\n        }\n        // WARNING: This sleep here is to fix a bug\n        // When we open/close settings we trigger this function but it takes the size of the window before changing\n        // The sleep fixes this problem altought the delay is 0\n        await sleep(0);\n        stageRef.current.handleResize();\n      }, []);\n      // connect the handle to events\n      useEffect(() => {\n        window.addEventListener('resize', handleResize);\n        return () => {\n          window.removeEventListener('resize', handleResize);\n        };\n      }, [handleResize]);\n\n      // PDB file, base structure\n      // Set the representations in each component\n      useEffect(() => {\n        if (!pdbFile || !components || !representations) return;\n        // Atom occupancy is a field which is not used anywhere but in the electrostatic representation\n        // The electrostatic surface scheme color does not work if the occupancy is 0 (ngl code, not ours)\n        // We set all occupancies to 1, since some topologies may have all occupancies as 0 by default\n        pdbFile.atomStore.occupancy = new Array(\n          pdbFile.atomStore.occupancy.length,\n        ).fill(1);\n\n        // All topologies must be ready before we start loading the components to stage\n        // DANI: Esto es tentador quitarlo para que las topologías vayan cargando cuando llegan\n        // DANI: No obstante, es un percal, hay que hacerlo con tiempo\n        // DANI: Los components de stageRef.current.compList deben estar en orden\n        if (anyLoadingTopology) return;\n\n        components.forEach((comp, c) => {\n          // Set the NGL component\n          let stageComp = stageRef.current.compList[c];\n          if (!stageComp) {\n            // Find the topology which matches the component url\n            // If a component has no url it will match a topology with no url: the default topology\n            const url = comp.topologyURL || null;\n            const topology = topologies.find(topology => {\n              return topology.url === url;\n            });\n            // If the topology has not been loaded yet then we have a problem\n            // DANI: Todas las topologías deben estar ya listas antes de cargarlas, lee los mensajes de arriba\n            if (!topology) return;\n            // Stop here if it is not downloaded yet\n            if (topology.error)\n              throw new Error(\n                `Topology from '${url}' returned error ${topology.error}`,\n              );\n            if (!topology.file)\n              throw new Error(`Topology data from '${url}' is missing`);\n            // Add the topology to the NGL\n            // Make a deep copy of the topology object to prevent NGL internal bugs\n            // This object will store data which is component exclusive\n            const componentObject = cloneDeep(topology.file);\n            //const componentObject = topology.file;\n            stageRef.current.addComponentFromObject(componentObject);\n            stageComp = stageRef.current.compList[c];\n            stageComp.onlyTopology = comp.onlyTopology;\n            setIsFirstCompStaged(true);\n          }\n\n          // Get current component representations\n          const componentRepresentations = representations.filter(rep => rep.component === comp.name);\n\n          // Set each representation\n          // Delete previous representations which are not requested anymore\n          const registredNames = [];\n          componentRepresentations.forEach((rep, r) => {\n            // The name here is used to indetify previous existing representations\n            const name = r + '-' + rep.name;\n            registredNames.push(name);\n\n            // Adapt a few representation values to the context\n            const show = rep.show\n            const sele = rep.selection;\n            const type = rep.type;\n            const color = rep.color;\n            const opacity = show ? rep.opacity : 0;\n\n            const customColorScheme = rep.customScheme;\n\n            // If the representation is selected then the color is yellow\n            const colorScheme = rep.name === selectedRepresentation\n              ? ColormakerRegistry.addSelectionScheme(\n                  [['yellow', 'all']],\n                  'custom label',\n                )\n              // If the colorScheme is in the passed custom schemes use it\n              : customColorScheme && color === 'custom'\n                ? customColorScheme\n                // If the colorScheme is a defined color, create a custom colorScheme for this color\n                : isValidColor(color)\n                  ? ColormakerRegistry.addSelectionScheme(\n                      [[color, 'all']],\n                      'custom label',\n                    )\n                  // Otherwise let the color scheme as it is\n                  : color;\n\n            // Set some additional parameters which are to be modified depending on the type\n            const colorDomain = type === 'surface' ? [-200, 200] : undefined;\n            const surfaceType = type === 'surface' ? 'av' : undefined;\n            //const background = type === 'surface' && opacity < 1 ? true : false;\n            const depthWrite = type === 'surface' && opacity < 1 ? false : true;\n\n            // Join all parameters into a single input object\n            const parameters = {\n              sele,\n              name,\n              opacity,\n              colorScheme,\n              colorDomain,\n              surfaceType,\n              side: 'front',\n              //background,\n              depthWrite,\n              //opaqueBack: true,\n              //forceTransparent: true,\n              ...rep.other,\n            };\n\n            // Find the previous representation\n            const previousRepresentation = stageComp.reprList.find(\n              previous => previous.name === name,\n            );\n\n            // Update the previous representation if exists\n            if (previousRepresentation) {\n              const previousType = previousRepresentation.repr.type;\n              const previousSelection =\n                previousRepresentation.repr.selection.string;\n              // If the 'drawingMethod' has been changed we have to remake the whole representation\n              // WARNING: Representations with 'trace' type must be remade always\n              // WARNING: Reseting their parameters returns a fatal error. It is an internal NGL bug.\n              if (\n                previousType !== type ||\n                previousSelection !== sele ||\n                previousType === 'trace'\n              ) {\n                stageComp.removeRepresentation(previousRepresentation);\n                stageComp.addRepresentation(type, parameters);\n              }\n              // Otherwise it is faster just to update the parameters\n              else {\n                previousRepresentation.setParameters(parameters);\n              }\n            }\n            // If there is no previous representation then set a new one\n            else {\n              stageComp.addRepresentation(type, parameters);\n            }\n\n            // Add a floating label over the representation when it is specified\n            const label = rep.label;\n            if (label) {\n              const name = rep.label + '-' + name;\n              // Find the equivalent previous label\n              const previous = stageComp.annotationList.find(\n                annotation => annotation.name === name,\n              );\n              //console.log(previous);\n              // If the representation is shown\n              if (show) {\n                // If there is a previous representation then just update the label\n                // The rest should be always the same\n                if (previous) {\n                  previous.element.label = rep.label;\n                }\n                // If there is not previous label then set it\n                else {\n                  var elm = document.createElement('div');\n                  elm.innerText = rep.label;\n                  elm.style.color = '#76FF03';\n                  elm.style.backgroundColor = '#607D8B';\n                  elm.style.padding = '8px';\n                  // get the geometrical center of the representation\n                  const center = stageComp.reprList[r].repr.structureView.center;\n                  const annotation = stageComp.addAnnotation(center, elm);\n                  annotation.name = name;\n                }\n              }\n              // If the representation is hidden\n              else {\n                // If there is a previous representation then remove it\n                if (previous) {\n                  stageComp.removeAnnotation(previous);\n                }\n              }\n            }\n\n            // Set this representation as the focus if it is selected\n            if (rep.name === selectedRepresentation) {\n              setFocus({ comp: c, sele: rep.selection });\n              //focused = true;\n            }\n          });\n\n          // Delete all representations which are not required anymore\n          // WARNING: It is very important to save apart the stageComp.reprList\n          // WARNING: Do not iterate over stageComp.reprList while removing representations\n          // WARNING: If so, representations would jump of index in the list\n          const previousRepresentations = [...stageComp.reprList];\n          previousRepresentations.forEach(rep => {\n            const name = rep.name;\n            // Representations with name starting with '*' are never removed by this way\n            // Those representations are automatic highlights\n            if (name.charAt(0) === '*') return;\n            for (const registredName of registredNames) {\n              if (name === registredName) return;\n            }\n            // If the name is not in the list the representation must be removed\n            stageComp.removeRepresentation(rep);\n          });\n\n          // If nothing has been focused at the end then focus the whole first component\n          setFocus(previous => {\n            if (previous) return previous; // This will not trigger any rerender\n            return { comp: 0, sele: 'all' };\n          });\n        });\n      }, [\n        pdbFile,\n        components,\n        representations,\n        anyLoadingTopology,\n        topologies,\n        selectedRepresentation,\n      ]);\n\n      // Highlight specific atoms\n      useEffect(() => {\n        if (!topologyManager) return;\n        // DANI: He tenido que quitar la condicion de 'instanceof Set' porque sino no me entraba en el heatmap\n        //if (!pdbFile || !(selectedAtoms instanceof Set) || !(selectedAtoms)) {\n        if (!isFirstCompStaged || !selectedAtoms) {\n          return;\n        }\n\n        // Set a representation name\n        // This is useful to find previous representations in further renders\n        const nameHighlight = '*highlightedAtoms';\n        const previousHighlightRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation) {\n          stageRef.current.compList[0].removeRepresentation(\n            previousHighlightRepresentation,\n          );\n        }\n\n        // Name for residues representation\n        const nameContextHighlight = '*highlightedAtomResidues';\n        const previousContextRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === nameContextHighlight,\n        );\n        if (previousContextRepresentation) {\n          stageRef.current.compList[0].removeRepresentation(\n            previousContextRepresentation,\n          );\n        }\n\n        const atoms = Array.from(selectedAtoms);\n        if (!atoms.length) return;\n\n        // ngl starts counting at 0\n        const seleHighlight = `@${atoms.map(atomIndex => atomIndex).join(',')}`;\n\n        stageRef.current.compList[0].addRepresentation(highlightTypes.atoms, {\n          sele: seleHighlight,\n          opacity: 0.5,\n          scale: 1.5,\n          name: nameHighlight,\n        });\n\n        const otherResidueAtomsSelection = Array.from(\n          new Set(\n            // 'atoms' are in abolsute numeration\n            atoms.map(atomIndex => {\n              const residueIndex = topologyManager.getAtomResidueIndex(\n                atomIndex,\n              );\n              const atomIndices = topologyManager.getResidueByIndex(residueIndex).atomIndices;\n              const nglAtomSelection = '@' + atomIndices.join(',');\n              return nglAtomSelection;\n            }),\n          ),\n        ).join(' or ');\n\n        stageRef.current.compList[0].addRepresentation(\n          highlightTypes.residues,\n          {\n            sele: otherResidueAtomsSelection,\n            name: nameContextHighlight,\n          },\n        );\n\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: otherResidueAtomsSelection });\n      }, [\n        isFirstCompStaged,\n        topologyManager,\n        selectedAtoms,\n        darkBackground,\n        highlightTypes,\n      ]);\n\n      // Highlight specific residues\n      useEffect(() => {\n        if (!topologyManager || !isFirstCompStaged || !selectedResidueIndices) return;\n        // Set a representation name. This is useful to find this representation further\n        const nameHighlight = '*highlightedResidues';\n        const previousHighlightRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation)\n          stageRef.current.compList[0].removeRepresentation(\n            previousHighlightRepresentation,\n          );\n        // If there are no selected residues at all we stop here\n        if (selectedResidueIndices.length === 0) return;\n        // Get the residues input\n        const residueNglSelections = selectedResidueIndices.map(\n          residueIndex =>\n            topologyManager.getResidueByIndex(residueIndex).nglSelection,\n        );\n        // Transform the residues list into an NGL selection\n        const overallNglSelection = Array.from(\n          new Set(residueNglSelections),\n        ).join(' or ');\n        // Represent the previous selection in ball+sticks drawing method\n        stageRef.current.compList[0].addRepresentation(\n          highlightTypes.residues,\n          {\n            sele: overallNglSelection,\n            name: nameHighlight,\n          },\n        );\n\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: overallNglSelection });\n      }, [\n        isFirstCompStaged,\n        selectedResidueIndices,\n        topologyManager,\n        highlightTypes,\n      ]);\n\n      // Highlight specific chains\n      // DANI: NO Probado\n      useEffect(() => {\n        if (!isFirstCompStaged || !selectedChains) {\n          return;\n        }\n        // Set a representation name. This is useful to find this representation further\n        const nameHighlight = '*highlightedChains';\n        const previousHighlightRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation)\n          stageRef.current.compList[0].removeRepresentation(\n            previousHighlightRepresentation,\n          );\n\n        // Get the residues input\n        const chains = selectedChains.map(c => ':' + c);\n        if (!chains.length) return;\n        // Transform the residues list into an NGL selection\n        const nglSelection = Array.from(new Set(chains)).join(' or ');\n\n        // Represent the previous selection in ball+sticks drawing method\n        stageRef.current.compList[0].addRepresentation(highlightTypes.chains, {\n          sele: nglSelection,\n          name: nameHighlight,\n        });\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: nglSelection });\n      }, [isFirstCompStaged, selectedChains, highlightTypes]);\n\n      // Highlight specific free NGL selections\n      useEffect(() => {\n        if (!isFirstCompStaged || !snapRepresentations) return;\n        const currentComponent = stageRef.current.compList[0];\n        const currentRepresentations = currentComponent.reprList;\n        snapRepresentations.forEach(snapRepresentation => {\n          currentComponent.addRepresentation(snapRepresentation.type, {\n            sele: snapRepresentation.selection,\n            name: snapRepresentation.name,\n            color: snapRepresentation.color,\n            opacity: snapRepresentation.opacity,\n          });\n        });\n        return () => {\n          snapRepresentations.forEach(snapRepresentation => {\n            // Find if the current snap representation already exists by its name\n            const previousSnapRepresentation = currentRepresentations.find(\n              currentRepresentation =>\n                currentRepresentation.name === snapRepresentation.name,\n            );\n            // If so, remove it\n            if (previousSnapRepresentation)\n              currentComponent.removeRepresentation(previousSnapRepresentation);\n          });\n        };\n      }, [isFirstCompStaged, snapRepresentations]);\n\n      // Add specific NGL representations which are added or removed apart from the main component\n      // They are faster to update but they are not shown in the representations manager\n      useEffect(() => {\n        if (!isFirstCompStaged || !selectedCustom) {\n          return;\n        }\n        // Set a representation name. This is useful to find this representation further\n        const nameHighlight = '*highlightedCustom';\n        const previousHighlightRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === nameHighlight,\n        );\n        if (previousHighlightRepresentation)\n          stageRef.current.compList[0].removeRepresentation(\n            previousHighlightRepresentation,\n          );\n\n        if (!selectedCustom.length) return;\n        // Transform the residues list into an NGL selection\n        const nglSelection = Array.from(new Set(selectedCustom)).join(' or ');\n\n        // Represent the previous selection in ball+sticks drawing method\n        stageRef.current.compList[0].addRepresentation(\n          highlightTypes.selections,\n          {\n            sele: nglSelection,\n            name: nameHighlight,\n          },\n        );\n        // Focus the highlighted zone with the camera\n        setFocus({ comp: 0, sele: nglSelection });\n      }, [isFirstCompStaged, selectedCustom, highlightTypes]);\n\n      // Highlight specific distances\n      // When 'selectedDistances' is numeric it is taken as atoms\n      // When 'selectedDistances' is string it is taken as residues\n      // In both cases it works with residue indices\n      useEffect(() => {\n        if (!isFirstCompStaged || !selectedDistances) {\n          return;\n        }\n        //console.log(selectedDistances);\n        // Set a representation name. This is useful to find this representation further\n        const name = '*distance';\n        const previousRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === name,\n        );\n        // Remove the previous representation\n        if (previousRepresentation)\n          stageRef.current.compList[0].removeRepresentation(\n            previousRepresentation,\n          );\n\n        // Display the new distance representation\n        stageRef.current.compList[0].addRepresentation('distance', {\n          atomPair: selectedDistances,\n          color: 'skyblue',\n          labelUnit: 'angstrom',\n          name: name,\n          // Label color is the opposite of the background color\n          labelColor: darkBackground ? 16777215 : 1, // 16777215 is white, 1 is black\n        });\n      }, [isFirstCompStaged, selectedDistances, darkBackground]);\n\n      // Highlight specific angles\n      useEffect(() => {\n        if (!isFirstCompStaged || !selectedAngles) {\n          return;\n        }\n        // Set a representation name. This is useful to find this representation further\n        const name = '*angles';\n        const previousRepresentation = stageRef.current.compList[0].reprList.find(\n          representation => representation.name === name,\n        );\n        if (previousRepresentation)\n          stageRef.current.compList[0].removeRepresentation(\n            previousRepresentation,\n          );\n\n        stageRef.current.compList[0].addRepresentation('angle', {\n          atomTriple: selectedAngles,\n          name: name,\n          labelColor: darkBackground ? 16777215 : 1, // 16777215 is white, 1 is black\n        });\n      }, [isFirstCompStaged, selectedAngles, darkBackground]);\n\n      const [mainNglFile, setMainNglFile] = useState(null);\n\n      // DCD file, trajectory\n      // Once the trajectories are downloaded, load them in corresponding NGL representations\n      // Every time the trajectory payloads change this useEffect must be rerun\n      useEffect(() => {\n        // Check if trajectories are\n        if (!topologies || !trajectories || trajectories.length === 0) return;\n\n        components.forEach((comp, c) => {\n          // Find the topology which matches the component url\n          // If a component has no url it will match a topology with no url: the default topology\n          const url = comp.topologyURL || null;\n          const topology = topologies.find(topology => topology.url === url);\n          const stageComp = stageRef.current.compList[c];\n          // Wait if the topology has not been loaded yet\n          if (!stageComp) return;\n          // Abort if the component is marked as 'only topology'\n          if (stageComp.onlyTopology) return;\n          // Find the trajectory payload from the component urls and join them\n          const trajectoryPayloads = [];\n          // Save the combined urls of all trajectories and their lengths\n          // This is used in further renders to know if current trajectory is new or the same\n          let combinedURL = '';\n          let combinedProgress = '';\n          // Record also the atoms for each trajectory and check that they match\n          let trajectoryAtoms;\n          let trajectoryFinalExpectedFrames = 0;\n          // Record also the frames for each trajectory and add them\n          for (const url of comp.framedURLs) {\n            const trajectory = trajectories.find(trajectory => trajectory.url === url);\n            // If the trajectory is not downloaded yet then exit\n            if (!trajectory) return;\n            // Get atom counts from different trajectories and check they match\n            if (!trajectoryAtoms) trajectoryAtoms = trajectory.atoms;\n            if (trajectoryAtoms !== trajectory.atoms)\n              throw new Error( `Atoms number in the different trajectories do not match`);\n            // Add the final expected frames for all frames in the component\n            trajectoryFinalExpectedFrames += trajectory.frames;\n            // Add the main data to the array of payloads\n            // Substract data from not completed frames\n            const payload = trajectory.payload;\n            const bytesPerFrame = trajectoryAtoms * BYTES_PER_ATOM;\n            const fitLength = Math.floor(payload.byteLength / bytesPerFrame) * bytesPerFrame;\n            const fitPayload = payload.slice(0, fitLength);\n            trajectoryPayloads.push(fitPayload);\n            combinedURL += url;\n            combinedProgress += '/' + trajectory.progress;\n          }\n\n          // Check if we are loading the same trajectory than before\n          const sameTrajectory = stageComp.combinedURL === combinedURL;\n\n          // If we are loading a different trajectory then remove all possibly already existing trajectories\n          // This return an error in console: \"updateStructure: traj disposed\"\n          // This may be a bug but it is actually working\n          // See https://github.com/arose/ngl/issues/680\n          if (!sameTrajectory)\n            stageComp.trajList.forEach(\n              stageComp.removeTrajectory.bind(stageComp),\n            );\n\n          // If both URL and progress are matching then exit here\n          if (sameTrajectory && stageComp.combinedProgress === combinedProgress)\n            return;\n\n          // Save current URL in the staged component\n          stageComp.combinedURL = combinedURL;\n          stageComp.combinedProgress = combinedProgress;\n\n          // Join all payloads into a single trajectory\n          let totalPayload;\n          if (trajectoryPayloads.length === 1)\n            totalPayload = trajectoryPayloads[0];\n          // DANI: Esto no está bien ahora que hay streaming\n          // DANI: Si hubiese dos trayectorias combinadas sus frames quedarían entrelazadas\n          // DANI: Pero las trayectorias combinadas no se usan, así que no me merece la pena mantenerlo\n          else\n            totalPayload = trajectoryPayloads.reduce((cb, nb) =>\n              appendBuffer(cb, nb),\n            );\n          // If the total payload is empty then stop here\n          if (totalPayload.byteLength === 0) return;\n          // Calculate how many frames are there in total\n          const bytesPerFrame = trajectoryAtoms * BYTES_PER_ATOM;\n          const totalFrames = totalPayload.byteLength / bytesPerFrame;\n          const lastFrameIndex = totalFrames - 1;\n          // Check if all required data is already downloaded\n          const completedTrajectory =\n            totalFrames === trajectoryFinalExpectedFrames;\n\n          // Get the atom indices whom the trajectory coordinates belong to, in case it is passed\n          const trajectoryAtomIndices = comp.trajectoryAtomIndices;\n\n          // Get the current NGL loaded trajectories\n          const compTrajectories = stageComp.trajList;\n\n          // If there is a trajectory already update it with new data\n          if (compTrajectories.length > 0) {\n            // There must be only one trajectory\n            if (compTrajectories.length > 1)\n              throw new Error(`Multiple trajectories in one component`);\n            const nglFile = compTrajectories[0];\n            const nglTrajectory = nglFile.trajectory;\n            updateNGLFile(\n              nglTrajectory,\n              topology.file,\n              totalPayload,\n              trajectoryAtoms,\n              totalFrames,\n              trajectoryAtomIndices,\n            );\n            // Adjust some parameters after the trajectory data has been changed\n            nglTrajectory._frameCount = totalFrames;\n            if (c === 0) {\n              // Save the expected frames number here in the NGL file\n              // This is further use by the frame change handler\n              nglFile.expectedFrames = trajectoryFinalExpectedFrames;\n              const nglPlayer = nglTrajectory.player;\n              // Set animation player parameters\n              const timeout = interpolateSpeed(speed);\n              nglPlayer.setParameters({\n                end: lastFrameIndex,\n                interpolateStep: 100 / trajectoryFinalExpectedFrames, // This must be set every time\n                mode: completedTrajectory ? 'loop' : 'once',\n                timeout: timeout,\n              });\n              // If the trajectory was paused because it had no more frames to load then resume it\n              if (!noTrajectory && playing && !nglPlayer.isRunning) {\n                const currentFrame = nglTrajectory._currentFrame;\n                const endingFrame = lastFrameIndex;\n                if (currentFrame < endingFrame) nglPlayer.play();\n              }\n            }\n          }\n          // If there is not trajectory yet then create a new NGL trajectory\n          else {\n            // Transform the binary trajectory data to an NGL friendly format\n            const file = setNGLFile(\n              topology.file,\n              totalPayload,\n              trajectoryAtoms,\n              totalFrames,\n              trajectoryAtomIndices,\n            );\n            if (!file) return;\n            const nglFile = stageComp.addTrajectory(file);\n            const nglTrajectory = nglFile.trajectory;\n            // Count the real numer of frames in the current trajectory and reset the 'requestedFramesNumber'\n            // DANI: Esto lo he quitado porque creo que podría dar problemas\n            // DANI: Las requestedFramesNumber son el número de frames que se piden, no el real\n            // DANI: Si hay que mostrar el número real en algún punto mejor crea otro state\n            // if (setRequestedFramesNumber && c === 0) {\n            //   const frameCount = nglTrajectory.frameCount;\n            //   setRequestedFramesNumber(frameCount);\n            // }\n            // Add the frame change handler only if it is the main component\n            if (c === 0) {\n              // Save the expected frames number here in the NGL file\n              // This is further use by the frame change handler\n              nglFile.expectedFrames = trajectoryFinalExpectedFrames;\n              // Set animation player parameters\n              const timeout = interpolateSpeed(speed);\n              nglTrajectory.player.setParameters({\n                interpolateStep: 100 / trajectoryFinalExpectedFrames,\n                mode: completedTrajectory ? 'loop' : 'once',\n                timeout: timeout,\n              });\n              // Update the main NGL file\n              setMainNglFile(nglFile);\n              setIsMainTrajectoryStaged(true);\n            }\n            // Set trajectory frame\n            nglTrajectory.setFrame(0);\n          }\n        });\n      }, [\n        topologies,\n        trajectories,\n        components,\n        noTrajectory,\n        setMainNglFile,\n        // The requestedFramesNumber dependency may seem redundant but it is not\n        // It is useful to switch between previously downloaded trajectories with different number of frames\n        requestedFramesNumber,\n        // This playing here is just to avoid the warning\n        // I can't disable the warning with \"// eslint-disable-line react-hooks/exhaustive-deps\"\n        // This is because the automatic formatter puts the warning one line down because it is stupid\n        // Anyway the warning is also stupid, because using the playing as dependency is counterproductive\n        // To sum up: when eslint gets smarter and stops complaining you can remove playing from dependencies\n        playing,\n        // It is the same with the speed that with the playing\n        speed,\n      ]);\n\n      // Add a signaled handler to the main NGl file, which contains the mian trajectory\n      useEffect(() => {\n        // Set a function to make the trajectory never stop at any interpolation step\n        // If it is stopped in the middle of an interpolation then jump to the next frame\n        if (!mainNglFile) return;\n        const nglTrajectory = mainNglFile.trajectory;\n        const goToNextFrame = () => {\n          const currentFrame = nglTrajectory._currentFrame;\n          nglTrajectory.setFrame(currentFrame);\n        };\n        nglTrajectory.player.signals.haltedRunning.add(goToNextFrame);\n        // Removing NGL without removing signals from the trajectory player is fatal\n        // This raises the error \"Uncaught TypeError: this._bindings is undefined\"\n        // Set a cleanup function to prevent fatal errors\n        return () => {\n          nglTrajectory.player.signals.haltedRunning.remove(goToNextFrame);\n        }\n      }, [mainNglFile]);\n\n      // play/pause\n      useEffect(() => {\n        if (!(isFirstCompStaged && isMainTrajectoryStaged)) return;\n        const mainTraj =\n          stageRef.current &&\n          stageRef.current.compList[0] &&\n          stageRef.current.compList[0].trajList[0];\n        if (!mainTraj) throw new Error('Something is wrong with NGL');\n        const { player } = stageRef.current.compList[0].trajList[0].trajectory;\n        player.setParameters({\n          // Set the interpolate step according to the total number of frames to show 1 by 1\n          interpolateStep: 100 / mainTraj.trajectory.frameCount,\n          // Set the animation to go forward and then backward instead of restart if required\n          direction: bounce ? 'bounce' : 'forward',\n        });\n        // WARNING: Pausing the player when there is no trajectory may seem redundant\n        // However, if not paused, the surface representations never stop to be calculated\n        if (noTrajectory) player.pause();\n        else player[playing && isInView ? 'play' : 'pause']();\n        // Remvoing NGL while the animation is playing is fatal\n        // This raises the error \"Uncaught TypeError: this._bindings is undefined\"\n        // Set a cleanup function to prevent fatal errors\n        return () => player.pause();\n      }, [\n        isFirstCompStaged,\n        isMainTrajectoryStaged,\n        playing,\n        isInView,\n        noTrajectory,\n        bounce,\n      ]);\n\n      // Handle the speed\n      // The speed is also self-regulated by NGL\n      // If the topology is too big to reach the required speed it will work as fast as possible\n      useEffect(() => {\n        // Get the current trajectory\n        if (!isFirstCompStaged) return;\n        const nglFile = stageRef.current.compList[0].trajList[0];\n        if (!nglFile) return;\n        // Set the player speed\n        // The 'speed' input ranges from 0 to 100\n        // The NGL 'timeout' parameter stands from the time to wait before moving to the next frame in miliseconds\n        //const timeout = 500 / (Math.log2(speed + 1) + 1);\n        const timeout = interpolateSpeed(speed);\n        nglFile.trajectory.player.setParameters({ timeout: timeout });\n      }, [isFirstCompStaged, speed]);\n\n      // spinning\n      useEffect(() => {\n        if (\n          stageRef.current &&\n          stageRef.current.spinAnimation &&\n          spinning === stageRef.current.spinAnimation.paused\n        ) {\n          stageRef.current.toggleSpin();\n        }\n      }, [spinning]);\n\n      // smoothing, player interpolation\n      useEffect(() => {\n        if (!(isFirstCompStaged && isMainTrajectoryStaged)) return;\n        stageRef.current.compList[0].trajList[0].trajectory.player.parameters.interpolateType = smooth\n          ? 'linear'\n          : '';\n      }, [isFirstCompStaged, isMainTrajectoryStaged, smooth]);\n\n      // to avoid sometimes when it's not rendering after loading\n      useEffect(() => {\n        if (!(isFirstCompStaged && requestedTrajectories.length)) return;\n        handleResize();\n        return handleResize.cancel;\n      }, [isFirstCompStaged, requestedTrajectories, handleResize]);\n\n      // Highlight the selected chain region\n      // This useEffect seems to be special:\n      // It is run just once but some parts inside keep running on change events\n      // listen to change event from nightingale component\n      useEffect(() => {\n        if (!topologyManager) return;\n        const handler = ({ detail }) => {\n          // escape case for event listener\n          if (!detail || !(detail.eventtype === 'click' || detail.eventtype === 'reset')) return;\n          let highlight = '';\n          for (const manager of document.querySelectorAll('protvista-manager')) {\n            // get highlight value for each manager\n            const thisHiglight = manager.attributeValues.get('highlight');\n            // Get the chain letter to know which chain has been selected\n            const chain = manager.attributes.chain.value;\n            // if none, escape\n            if (!thisHiglight) continue;\n            // Start and end values are in model numeration\n            // DANI: This is totally by chance. I didn't program this previous part\n            const [start, end] = thisHiglight.split(':');\n            const sourceStart = topologyManager.getResidueByParameters(chain, +start);\n            const sourceEnd = topologyManager.getResidueByParameters(chain, +end);\n            if (sourceStart.chainName !== sourceEnd.chainName)\n              throw new Error(`Range from multiple chains is not supported`);\n            highlight += ` or :${sourceStart.chainName} and ${sourceStart.number}-${sourceEnd.number}`;\n          }\n          highlight = highlight.substr(4); // remove initial ' or '\n\n          const structureComponent = stageRef.current.compList[0];\n\n          const previousStructureRepresentation = structureComponent &&\n            structureComponent.reprList.find(\n              representation => representation.name === 'structure',\n            );\n          if (previousStructureRepresentation)\n            structureComponent.removeRepresentation(previousStructureRepresentation);\n          // no highlight, then default coloring\n          if (!highlight) {\n            structureComponent.addRepresentation('cartoon', {\n              sele: CHAIN_SELECTION,\n              name: 'structure',\n              opacity: 1,\n            });\n            if (originalOritentationRef.current) {\n              stageRef.current.animationControls.orient(\n                originalOritentationRef.current,\n                DEFAULT_ORIENTATION_TRANSITION_DURATION,\n              );\n            }\n            return;\n          }\n\n          // otherwise, highlight accordingly\n          const colorSchemeID = ColormakerRegistry.addSelectionScheme(\n            [['yellow', highlight], ['white', '*']],\n            'custom label',\n          );\n          structureComponent.addRepresentation('cartoon', {\n            sele: CHAIN_SELECTION,\n            name: 'structure',\n            opacity: 1,\n            color: colorSchemeID,\n          });\n          structureComponent.autoView(\n            highlight,\n            DEFAULT_ORIENTATION_TRANSITION_DURATION,\n          );\n        };\n        window.addEventListener('change', handler);\n        return () => window.removeEventListener('change', handler);\n      }, [topologyManager]);\n\n      // Customize the NGL tooltip\n      useEffect(() => {\n        if (!topologyManager) return;\n        // Set a new tooltip\n        const tooltip = tooltipRef.current;\n        // WARNING: The following line is dangerous since you are manipulating the DOM outside of React\n        // If the tooltip component is not child of the viewer and you change to molstar then you have the following error:\n        // Node.removeChild: The node to be removed is not a child of this node\n        containerRef.current.appendChild(tooltip);\n\n        // Remove the original tooltip\n        stageRef.current.mouseControls.remove('hoverPick');\n\n        // Set a function which is used further to write a formatted output message to refer an atom\n        const formatOutput = atom => {\n          // a.residueIndex starts at 0\n          // WARNING: a.residueIndex is correct but we must convert it to source first\n          // In some cases 1 residue can have multiple residue indices\n          // (e.g. hydrogens at the end)\n          const residue = topologyManager.getResidueByIndex(atom.residueIndex);\n          const chainName = residue.chain.metadataChainName;\n          // Get the residue reference id\n          const referenceId = residue.referenceId;\n          return (\n            <>\n              {`Atom ${atom.index} (${atom.atomname})\n                Chain ${residue.chainName} ${chainName ? '(' + chainName + ')' : ''}\n                Residue ${residue.number} (${atom.resname})`}\n              {(() => {\n                // If there is not reference at all it means it is not even a protein\n                if (!referenceId) return;\n                // No referable flag is for proteins which are not to be referenced\n                // e.g. antibodies, synthetic constructs, etc.\n                if (referenceId === 'noref') return (\n                  <div style={{ color: 'orange' }}>{'No referable'}</div>\n                );\n                // The not found flag is for proteins which failed to be aligned in a blast\n                if (referenceId === 'notfound') return (\n                  <div style={{ color: 'salmon' }}>{'Reference not found'}</div>\n                );\n                // Show the reference and its residue references number\n                return (\n                  <div>\n                    <div style={{ color: 'lightGreen' }}>{residue.referenceName}</div>\n                    {residue.isProtein && <div>{`- Residue ${residue.referenceNumber}`}</div>}\n                  </div>\n                )\n              })()}\n            </>\n          );\n        };\n\n        // Save a timeout before displaying the tooltip\n        // This way we can kill the display in case the mouse is out before the timeout is over\n        let timeout;\n\n        // Set a function that both prevents the tooltip if it is about to appear and hides it is already displayed\n        const hideTooltip = () => {\n          clearTimeout(timeout);\n          tooltip.style.display = 'none';\n        };\n\n        // Show our tooltip with the corresponding values when the mouse hovers an atom/bond\n        stageRef.current.signals.hovered.add(function(pickingProxy) {\n          // When mouse is over something (i.e. bonds or atoms)\n          if (pickingProxy) {\n            // Set a timeout for the hover to do not be instantaneous\n            hideTooltip();\n            timeout = setTimeout(() => {\n              // handle tooltip text\n              let description;\n              const bond = pickingProxy.bond;\n              const atom = pickingProxy.atom;\n              // When we hover a bond\n              if (bond) {\n                const atom1 = bond.atom1;\n                const atom2 = bond.atom2;\n                description = (\n                  <>\n                    <div>{`Bond ${atom1.index} - ${atom2.index}`}</div>\n                    <hr style={{ color: 'lightGrey' }} />\n                    {formatOutput(atom1)}\n                    <hr style={{ color: 'lightGrey' }} />\n                    {formatOutput(atom2)}\n                  </>\n                );\n              }\n              // When we hover an atom\n              else if (atom) {\n                description = formatOutput(atom);\n              }\n              setTooltipContent(description);\n              // Handle tooltip position\n              // WARNING: It is important to make the display block before calculating the position\n              // This is because the position is calculated from the tooltip size, which would be 0 otherwise\n              tooltip.style.display = 'block';\n              const { x, y } = setTooltipPosition(\n                containerRef.current,\n                tooltip,\n                pickingProxy.mouse.position,\n                3,\n              );\n              tooltip.style.top = y + 'px';\n              tooltip.style.left = x + 'px';\n            }, 400); // Wait 0,4 secs before showing the tooltip\n          }\n          // When mouse is over nothing\n          else {\n            hideTooltip();\n          }\n        });\n\n        // Remove the tooltip when the mouse is out of the NGL viewer container\n        containerRef.current.addEventListener('mouseleave', hideTooltip, false);\n\n        // Cleaning function\n        return () => {\n          tooltip.remove();\n          containerRef.current.removeEventListener('mouseleave', hideTooltip);\n        };\n      }, [topologyManager, setTooltipContent]);\n\n      // Track when the first focus has been performed, since first focus is instantaneous\n      const firstFocus = useRef(true);\n      // Focus the specified ngl selection with the camera automatically\n      useEffect(() => {\n        if (!focus) return;\n        const comp = stageRef.current.compList[focus.comp];\n        if (!comp) return;\n        let transition = DEFAULT_ORIENTATION_TRANSITION_DURATION;\n        // First transition is instantaneous\n        if (firstFocus.current) {\n          transition = 0;\n          // if an original orientation was aleady defined\n          // (manually created, and stored in the API)\n          if (originalOritentationRef.current) {\n            // use it to set the initial orientation\n            stageRef.current.animationControls.orient(\n              originalOritentationRef.current,\n              0,\n            );\n          }\n          firstFocus.current = false;\n        }\n        comp.autoView(focus.sele, transition);\n      }, [isFirstCompStaged, focus]);\n\n      // Expose public methods and getters/setters\n      useImperativeHandle(\n        ref,\n        () => ({\n          autoResize: handleResize,\n          // Output the current orientation/focus in console\n          // Note: this is for the developer, not for the regular user\n          displayFocus() {\n            const orientation = stageRef.current.viewerControls.getOrientation();\n            const stringifiedArray = `[${orientation.elements.toString()}]`;\n            console.log(stringifiedArray);\n          },\n          centerFocus() {\n            setFocus({ comp: 0, sele: 'all' });\n            // Use the provided orientation, if any\n            if (!originalOritentationRef.current) return;\n            stageRef.current.animationControls.orient(\n              originalOritentationRef.current,\n              DEFAULT_ORIENTATION_TRANSITION_DURATION,\n            );\n          },\n          get currentFrame() {\n            if (!(isFirstCompStaged && requestedTrajectories.length)) return -1;\n            try {\n              return stageRef.current.compList[0].trajList[0].trajectory\n                .currentFrame;\n            } catch (_) {\n              return -1;\n            }\n          },\n          set currentFrame(value) {\n            if (!(isFirstCompStaged && requestedTrajectories.length)) return;\n            try {\n              const total = this.totalFrames;\n              let frame = value;\n              if (frame < 0) frame = 0;\n              if (frame >= total) frame = total - 1;\n              stageRef.current.compList[0].trajList[0].trajectory.setFrame(\n                frame,\n              );\n            } catch (_) {\n              /* */\n            }\n          },\n          get totalFrames() {\n            if (!(isFirstCompStaged && requestedTrajectories.length)) return 1;\n            try {\n              return stageRef.current.compList[0].trajList[0].trajectory.frames\n                .length;\n            } catch (_) {\n              return 1;\n            }\n          },\n          get totalExpectedFrames() {\n            try {\n              return stageRef.current.compList[0].trajList[0].expectedFrames;\n            } catch (_) {\n              return 1;\n            }\n          },\n        }),\n        [isFirstCompStaged, requestedTrajectories, handleResize],\n      );\n\n      // workaround to have multiple ref logic on one element\n      // https://github.com/thebuilder/react-intersection-observer/issues/186#issuecomment-468641525\n      const handleRef = node => {\n        // If node does not exist then do not assign null to containerRef\n        // This way cleanup functions from some useEffects can properly clean the last reference\n        if (!node) return;\n        inViewRef(node);\n        containerRef.current = node;\n      };\n\n      // Finally, render the ngl window\n      return (\n        <>\n          <div\n            ref={handleRef}\n            className={cn(className, style.container, {\n              [style['loading-structure']]: !isFirstCompStaged,\n              [style['loading-trajectory']]:\n                !noTrajectory && anyLoadingTrajectory,\n              [style['light-theme']]: !darkBackground,\n            })}\n            // Display loading status data in the upper left corner of the NGL window\n            data-loading={viewerLogs}\n          >\n            <div ref={tooltipRef} className={style.tooltip}>\n              {tooltipContent}\n            </div>\n          </div>\n        </>\n      );\n    },\n  ),\n);\n\nexport default NGLViewer;\n","export const LOW = Symbol('low');\nexport const MEDIUM = Symbol('medium');\nexport const HIGH = Symbol('high');\n\n// Check how fast the connection is and send the corresponding symbol\n// WARNING: This is done for Chrome. i.e. Firefox will always return MEDIUM\nconst connectionLevel = () => {\n  if (!(navigator && navigator.connection)) return MEDIUM;\n  const { effectiveType, saveData } = navigator.connection;\n  if (saveData === true) return LOW;\n  if (!effectiveType) return MEDIUM;\n  switch (effectiveType) {\n    case 'slow-2g':\n    case '2g':\n      return LOW;\n    case '3g':\n      return MEDIUM;\n    case '4g':\n      return HIGH;\n    default:\n      return HIGH;\n  }\n};\n\nexport default connectionLevel;\n","// extracted by mini-css-extract-plugin\nexport default {\"background-toggle\":\"style_background-toggle__aAj32\",\"dark\":\"style_dark__e5mDQ\",\"adapter\":\"style_adapter__+rjEA\",\"ngl-with-settings\":\"style_ngl-with-settings__k93CW\",\"ngl-without-settings\":\"style_ngl-without-settings__qTooi\",\"settings-left\":\"style_settings-left__Wvi5a\",\"settings-controls\":\"style_settings-controls__kLLNo\",\"ngl-alone\":\"style_ngl-alone__5TmnB\",\"stacked-icons\":\"style_stacked-icons__OoF+a\",\"extra-top-margin\":\"style_extra-top-margin__vaEmm\",\"settings-right\":\"style_settings-right__NDIcU\",\"hidden\":\"style_hidden__D+3lX\",\"fullscreen-toggle\":\"style_fullscreen-toggle__f4Bk2\",\"expand\":\"style_expand__brMFA\",\"is-fullscreen\":\"style_is-fullscreen__RtQvN\",\"compress\":\"style_compress__xLnUE\",\"settings\":\"style_settings__87jIw\",\"fullscreen-target\":\"style_fullscreen-target__VO3Yh\",\"card-content\":\"style_card-content__Y2hw3\",\"progress\":\"style_progress__LNzos\",\"container\":\"style_container__ERsvh\",\"controls\":\"style_controls__0ugFi\",\"slider\":\"style_slider__FgVYz\",\"flip-container\":\"style_flip-container__dGHQ+\",\"flip-card-container\":\"style_flip-card-container__wgyMe\",\"flipped\":\"style_flipped__DhDpU\",\"flip-card\":\"style_flip-card__g+agx\",\"front\":\"style_front__g9FOf\",\"back\":\"style_back__UfiiZ\"};","// React logic\nimport React, {\n  useCallback,\n  useState,\n  useEffect,\n  useRef,\n  useMemo,\n  forwardRef,\n  useImperativeHandle,\n  useContext,\n} from 'react';\nimport cn from 'classnames';\nimport screenfull from 'screenfull';\n// Visual assets\nimport {\n  Card,\n  CardContent,\n  Grid,\n  LinearProgress,\n  Icon,\n  IconButton,\n  Slider,\n} from '@mui/material';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport {\n  faDotCircle,\n  faImages,\n  faSquare,\n} from '@fortawesome/free-regular-svg-icons';\nimport {\n  faStepBackward,\n  faStepForward,\n  faPause,\n  faPlay,\n  faExpand,\n  faCompress,\n  faSyncAlt,\n  faVideo,\n  faAdjust,\n  faCog,\n  faCube,\n  faWalking,\n  faBiking,\n  faTimes,\n  faLock,\n  faUnlock,\n  faStarOfLife,\n  faShareAlt, // It looks like connected atoms\n} from '@fortawesome/free-solid-svg-icons';\n\nimport RepresentationsManager from './representations-manager';\n\nimport { get, setAsync } from '../../utils/storage';\n\n// To ask the API\nimport { BASE_PATH_PROJECTS } from '../../utils/constants';\n\n// The main component of the viewer itself\nimport MolstarViewer from '../molstar-viewer';\nimport NGLViewer from '../ngl-viewer';\nimport useDefaultRepresentations from '../ngl-viewer/use-default-representations';\n\n// Hooks\nimport useToggleState from '../../hooks/use-toggle-state';\n\nimport connectionLevel, {\n  LOW,\n  MEDIUM,\n  HIGH,\n} from '../../utils/connection-level';\nimport reducedMotion from '../../utils/reduced-motion';\n\nimport style from './style.module.css';\n\nimport { ProjectCtx } from '../../contexts';\n\n// Decide that the default should be to play the trajectory only on \"big enough\"\n// screens (as a proxy for performance and low-end device detection)\nconst DEFAULT_STARTS_PLAYING = !reducedMotion() && window.innerWidth > 750;\n\nconst DEFAULT_FRAME_NUMBER = (() => {\n  switch (connectionLevel()) {\n    case HIGH:\n      return 50;\n    case MEDIUM:\n      return 25;\n    case LOW:\n    default:\n      return 10;\n  }\n})();\n\n// Set the possible number of frames the user can request\nconst DEFAULT_FRAME_NUMBERS = [\n  { value: 1, label: '1' },\n  { value: 10, label: '10' },\n  { value: 25, label: '25' },\n  { value: 50, label: '50' },\n  { value: 100, label: '100' },\n];\n\n// Set the default component parameters\n// These values are used to fill missing fields in input components\nconst DEFAULT_COMPONENT_PARAMETERS = {\n  name: 'Unnamed component',\n  topologyURL: 'auto', // This is assigned further\n  trajectoryURLs: 'auto', // This is assigned further\n  atomSelection: null,\n  frame: null,\n  onlyTopology: false\n}\n\n// Set the default representation parameters\n// These values are used to fill missing fields in input representations\nconst DEFAULT_REPRESENTATION_PARAMETERS = {\n  name: 'Unnamed representation',\n  selection: 'all',\n  show: true,\n  type: 'cartoon',\n  color: 'chainid',\n  opacity: 1,\n  component: 'auto' // This is assigned further\n}\n\n// DANI: falta representation.index y custom\n\n// Set a function to fill the missing values within an object using default values\n// Return true if there was any change\nconst completeMissingFields = (targetObject, defaultValuesObject) => {\n  let anyChange = false;\n  for (const [fieldName, defaultValue] of Object.entries(defaultValuesObject)) {\n    if (targetObject[fieldName] === undefined) {\n      targetObject[fieldName] = defaultValue;\n      anyChange = true;\n    }\n  }\n  return anyChange;\n}\n\n// Set an NGL view window which is managed by some controls\n// There are different ways to call this script\n// 1 - With components: Used for situations where more than a topology or trajectory are required\n// 2 - With representations: Which internally means there will be only 1 component\n// 3 - With no parameters: In which case a default representation in set up\n// * In case of both components and representations passed, the valid argument will be the components\n// WARNING: There are many important hooks which have components/representations as a dependency\n// Avoid passing an object which is created every render. Use a somehow memoized array.\n// WARNING: The style of this component and its parent is very important. Use a reference to call it\nconst ViewerWithControls = forwardRef(\n  (\n    {\n      // The viewer starting components\n      // Components are objects which may include the following values:\n      // All values are optional since missing values will be set by default\n      //  {\n      //    name: name of the component used to link representations with it\n      //    topologyURL: string, (used in pockets analysis)\n      //    trajectoryURLs: [ string ], (used in pca)\n      //    atomSelection: string, (used in pca)\n      //    frame: int, (used in rmsd pairwise analysis)\n      //    onlyTopology: bool, (used in pockets analysis)\n      //  }\n      startingComponents,\n      // The viewer starting representations\n      // It is an array of objects with the following structure:\n      // All values are optional since missing values will be set by default\n      // {\n      //   name: ('representation' by default) The string label of this representation,\n      //   show: ('true' by default) Boolean to set if this representation is shown or not,\n      //   selection: ('all' by default) The NGL selection string to define the atom selection,\n      //   type: ('cartoon' by default) The initial representation 'type',\n      //   color: ('chainid' by default) The initial representation 'colorScheme',\n      //   opacity: ('1' by default) The initial representation opacity\n      //   other: object with any other ngl options to be passed for the representation\n      //   component: name of the component this representation belongs to (main component when missing)\n      // }\n      startingRepresentations,\n      // Alternatively you may pass bot components and representations as states\n      // Thus the parent component may also control them\n      // Note that these states will be still controled by the child components anyway\n      componentsState,\n      representationsState,\n      // Style\n      className,\n      // Set if the viewer must play the simulation as soon as it appears\n      startsPlaying = DEFAULT_STARTS_PLAYING,\n      // Closing callback\n      close,\n      // Nailing callback\n      nail,\n      // Set which frame must be loaded. It may be undefined, if the whole trajectory is desired.\n      requestedFrame,\n      // Set if the frame number selector is allowed for trajectories (false in PCA projections)\n      framesSelect = true,\n      // Set a special option to force the 'noTrajectory' condition\n      // This is used to avoid the trajectory playing in pockets since there are surfaced representations\n      // This is only to be passed when having a trajectory loaded in the main component\n      // If a single frame is forced then this is redundant\n      preventTrajectory = false,\n      // Set a state setter to handle the frame progress\n      onProgress,\n      // The rest of properties\n      ...props\n    },\n    ref,\n  ) => {\n    // Make sure we are not having incompatible inputs\n    if (startingComponents && componentsState)\n      throw new Error('startingComponents and componentsState are not compatilbe inputs. Choose one.');\n    if (startingRepresentations && representationsState)\n      throw new Error('startingRepresentations and representationsState are not compatilbe inputs. Choose one.');\n    // Set which viewer is used: NGL or MolStar (the default is NGL)\n    const [Viewer, setViewer] = useState(NGLViewer);\n    // Get project metadata\n    const { metadata, accessionAndMdNumber, topology } = useContext(ProjectCtx);\n    // Use metadata to limit available frames number\n    const frameNumbers = useMemo(() => {\n      const maximumSnapshots = metadata.mdFrames;\n      const frameNumbers = [...DEFAULT_FRAME_NUMBERS];\n      // Remove values over the maximim number of frames\n      for (let i = frameNumbers.length - 1; i >= 0; i--) {\n        if (frameNumbers[i].value > maximumSnapshots) frameNumbers.pop();\n        else break;\n      }\n      // In case no value was removed we are done\n      if (frameNumbers.length === DEFAULT_FRAME_NUMBERS.length)\n        return frameNumbers;\n      // Otherwise, if the maximum number of frames is not one of the options already, then add it\n      if (frameNumbers[frameNumbers.length - 1].value !== maximumSnapshots)\n        frameNumbers.push({\n          value: maximumSnapshots,\n          label: maximumSnapshots.toString(),\n        });\n      return frameNumbers;\n    }, [metadata.mdFrames]);\n    // Do not use the start object but make a copy to avoid a lot of silent errors\n    const fixedStartingComponents = useMemo(() => {\n      // If there are no starting components then just leave it as null\n      // The defualt completer logic will take over\n      if (!startingComponents) return null;\n      return startingComponents.map(comp => JSON.parse(JSON.stringify(comp)));\n    }, [startingComponents]);\n\n    // Set the final components to be passed to the viewer\n    const [finalComponents, setFinalComponents] =\n      componentsState || useState(fixedStartingComponents);\n\n    // Set the missing value completer for components including URLs\n    // Return true if there was any change\n    const completeComponentMissingFields = useCallback(targetObject => {\n      if (!accessionAndMdNumber) return false;\n      const defaults = {...DEFAULT_COMPONENT_PARAMETERS};\n      defaults.topologyURL = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/structure`;\n      defaults.trajectoryURLs = [ `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/files/trajectory` ];\n      return completeMissingFields(targetObject, defaults);\n    }, [accessionAndMdNumber]);\n\n    // Anytime components change, check if there are any missing values and fill them with default values\n    useMemo(() => {\n      // Wait for the default completer to be ready\n      if (!completeComponentMissingFields) return;\n      // If there are no components then set a default configuration\n      if (!finalComponents) {\n        const defComponents = [{ name: 'Main' }];\n        defComponents.forEach(comp => { completeComponentMissingFields(comp) });\n        return setFinalComponents(defComponents);\n      }\n      // Make sure we have no components with the same name\n      const componentNames = finalComponents.map(comp => comp.name);\n      const uniqueComponentNames = new Set(componentNames);\n      if (componentNames.length !== uniqueComponentNames.size)\n        throw new Error(`We have multiple components with the same name: ${componentNames.join(', ')}`);\n      // Fill missing values among components with default values\n      const changes = finalComponents.map(comp => \n        completeComponentMissingFields(comp, DEFAULT_COMPONENT_PARAMETERS));\n      // If there was any value filled then update the state to trigger a rerender\n      if (changes.some(v => v === true)) setFinalComponents([...finalComponents]);\n    }, [finalComponents, completeComponentMissingFields]);\n\n    // Anytime the requested frame changes update the main component\n    useMemo(() => {\n      if (!finalComponents) return;\n      if (requestedFrame === undefined) return;\n      if (finalComponents[0].frame === requestedFrame) return;\n      finalComponents[0].frame = requestedFrame;\n      setFinalComponents([...finalComponents]);\n    }, [finalComponents, requestedFrame]);\n\n    // Do not use the start object but make a copy to avoid a lot of silent errors\n    const fixedStartingRepresentations = useMemo(() => {\n      // If there are no starting representations then just leave it as null\n      // The defualt completer logic will take over\n      if (!startingRepresentations) return null;\n      return startingRepresentations.map(rep => JSON.parse(JSON.stringify(rep)));\n    }, [startingRepresentations]);\n\n    // Set the final representations to be passed to the viewer\n    const [finalRepresentations, setFinalRepresentations] =\n      representationsState || useState(fixedStartingRepresentations);\n\n    // Use this hook to get the memoized NGL default representations\n    const defaultRepresentations = useDefaultRepresentations();\n\n    // Set the missing value completer for representations including the main component name\n    // Return true if there was any change\n    const completeRepresentationMissingFields = useCallback(targetObject => {\n      if (!finalComponents) return false;\n      const defaults = {...DEFAULT_REPRESENTATION_PARAMETERS};\n      defaults.component = finalComponents[0].name;\n      return completeMissingFields(targetObject, defaults);\n    }, [finalComponents]);\n\n    // Anytime representations change, check if there are any missing values and fill them\n    useMemo(() => {\n      // If we still have no default refereferences then stop here\n      if (!defaultRepresentations || defaultRepresentations.length === 0) return;\n      // If there are no representations then set a default configuration\n      if (!finalRepresentations) {\n        const defRepresentations = [...defaultRepresentations];\n        defRepresentations.forEach(rep => \n          completeRepresentationMissingFields(rep, DEFAULT_REPRESENTATION_PARAMETERS));\n        return setFinalRepresentations(defRepresentations);\n      }\n      // Fill missing values among representations with default values\n      const changes = finalRepresentations.map(rep => \n        completeRepresentationMissingFields(rep, DEFAULT_REPRESENTATION_PARAMETERS));\n      // If there was any value filled then update the state to trigger a rerender\n      if (changes.some(v => v === true)) setFinalRepresentations([...finalRepresentations]);\n    }, [finalRepresentations, defaultRepresentations, completeRepresentationMissingFields]);\n\n    // references\n    const containerRef = useRef(null);\n    const viewerRef = useRef(null);\n\n    // toggle states\n    const [nailed, toggleNailed] = useToggleState(false);\n    const [playing, togglePlaying] = useToggleState(startsPlaying);\n    const [spinning, toggleSpinning] = useToggleState(false);\n    const [smooth, setSmooth] = useState(true);\n    const [darkBackground, toggleDarkBackground] = useToggleState(\n      useMemo(() => get('dark-background', false), []),\n    );\n    const [perspective, togglePerspective] = useToggleState(\n      useMemo(() => get('perspective', false), []),\n    );\n\n    // states\n    const [progress, setProgress] = useState(0);\n    const [load, setLoad] = useState(0);\n    const [isFullscreen, setIsFullscreen] = useState(screenfull.isFullscreen);\n    const [requestedFramesNumber, setRequestedFramesNumber] = useState(\n      Math.min(DEFAULT_FRAME_NUMBER, metadata.mdFrames),\n    );\n    const [speed, setSpeed] = useState(useMemo(() => get('speed', 50), []));\n    const [settings, openSettings] = useState(false);\n\n    // handlers\n\n    // Handle the automatic progress\n    const handleProgress = useCallback(\n      prog => {\n        if (onProgress) onProgress(prog);\n        setProgress(prog);\n      }, [setProgress, onProgress],\n    );\n\n    // Handle the trajectory load\n    const handleLoad = useCallback(\n      load => {\n        setLoad(load);\n      }, [setLoad],\n    );\n\n    // handle click or click & drag progress bar\n    const handleManualProgress = useCallback(\n      ({ buttons, clientX, currentTarget, type }) => {\n        if (!viewerRef.current) return;\n        // if mousemove event, but the main button is not pressed, bail\n        if (type === 'mousemove' && buttons !== 1) return;\n        const { x, width } = currentTarget.getBoundingClientRect();\n        // Set pause\n        togglePlaying(false);\n        // Change the ngl viewer current ref from its exposed setter\n        // Then the ngl itself will update the 'progress' state\n        viewerRef.current.currentFrame = Math.floor(\n          ((clientX - x) / width) * viewerRef.current.totalExpectedFrames,\n        );\n      }, [togglePlaying],\n    );\n\n    // Frame change handler to interact with the child viewer\n    const handleFrameChange = useCallback(\n      value => {\n        if (!viewerRef.current) return;\n        togglePlaying(false);\n        viewerRef.current.currentFrame += value;\n      }, [togglePlaying],\n    );\n\n    // When the user requests the previous frame\n    const handlePreviousFrame = useCallback(() => handleFrameChange(-1), [handleFrameChange]);\n\n    // When the user requests the next frame\n    const handleNextFrame = useCallback(() => handleFrameChange(1), [handleFrameChange]);\n\n    // Enter/exit fullscreen\n    const handleFullscreenChange = useCallback(() => setIsFullscreen(screenfull.isFullscreen), []);\n    useEffect(() => {\n      screenfull.on('change', handleFullscreenChange);\n      return () => screenfull.off('change', handleFullscreenChange);\n    }, [handleFullscreenChange]);\n\n    // When the user clicks on the fullscreen button\n    const handlerFullscreenButton = useCallback(\n      () => { if (containerRef.current) screenfull.toggle(containerRef.current) }, []);\n\n    // Exit the options menu by pressing the escape key\n    useEffect(() => {\n      const handleKeyPress = event => {\n        if (event.key === 'Escape') openSettings(false);\n        viewerRef.current.autoResize();\n      };\n      document.addEventListener('keydown', handleKeyPress, false);\n      return () => document.removeEventListener('keydown', handleKeyPress, false);\n    }, []);\n\n    // Find out if there are residues under PBC (Periodic Boundary Conditions) in the topology\n    // If there are PBC residues then stop the smooth to prevent misleading artifacts\n    const hasPbcResidues = useMemo(() => {\n      if (!topology || !topology.pbcResidues) return;\n      const _hasPbcResidues = topology.pbcResidues.size > 0;\n      if (_hasPbcResidues) setSmooth(false);\n      return _hasPbcResidues;\n    }, [topology]);\n\n    // This allows parent components to interact with this component\n    useImperativeHandle(ref,\n      () => ({\n        autoResize: viewerRef.current.autoResize,\n        centerFocus: viewerRef.current.centerFocus,\n        get currentFrame() {\n          return viewerRef.current.currentFrame;\n        },\n        set currentFrame(value) {\n          viewerRef.current.currentFrame = value;\n        },\n        togglePlaying: togglePlaying,\n        setFinalComponents: setFinalComponents,\n        setFinalRepresentations: setFinalRepresentations\n      }),\n      [\n        togglePlaying,\n        setFinalComponents,\n        setFinalRepresentations,\n      ],\n    );\n\n    // Set the variable 'noTrajectory' as true when:\n    // The flag 'onlyTopology' is passed\n    // there is a selected unique frame to load from the main trajectory\n    // The main trajectory only has 1 frame (e.g. average.xtc)\n    const mainComponent = finalComponents && finalComponents[0];\n    const noTrajectory = preventTrajectory || (mainComponent && (mainComponent.onlyTopology ||\n      Number.isFinite(mainComponent.frame))); // May be 0\n\n    // DANI: Si no quieres buscarte problemas no cambies las \"Card\"s de aquí abajo por \"div\"s o similar\n    return (\n      <Card\n        className={cn(style['fullscreen-target'], {\n          [style['is-fullscreen']]: isFullscreen,\n        })}\n        ref={containerRef}\n      >\n        <div className={cn(style.adapter, className)}>\n          <Card\n            className={settings\n              ? style['ngl-with-settings']\n              : style['ngl-without-settings']\n            }\n            style={{ border: 'none', boxShadow: 'none' }}\n            // This id prevents the mouse to drag or resize the Rnd when it is over this element\n            id={'preventDragSize'}\n          >\n            <Card\n              className={settings\n                ? cn(style['settings-left'], className)\n                : cn(style['ngl-alone'], className)\n              }\n              style={{ border: 'none', boxShadow: 'none' }}\n            >\n              <Viewer\n                playing={playing}\n                spinning={spinning}\n                smooth={smooth}\n                onProgress={handleProgress}\n                onLoad={handleLoad}\n                ref={viewerRef}\n                noTrajectory={noTrajectory}\n                requestedFramesNumber={requestedFramesNumber}\n                darkBackground={darkBackground}\n                perspective={perspective}\n                speed={speed}\n                components={finalComponents}\n                representations={finalRepresentations}\n                {...props}\n              />\n              {settings && (\n                <div className={style['settings-controls']}>\n                  <div className={style['stacked-icons']}>\n                    <IconButton\n                      title=\"Toggle spin\"\n                      onClick={toggleSpinning}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faSyncAlt} />\n                    </IconButton>\n\n                    <IconButton\n                      title=\"Center focus\"\n                      onClick={event => {\n                        if (!viewerRef.current) return;\n                        // When the keys control, shift or command (ios) are hold while clicking\n                        const getFocus = event.shiftKey || event.ctrlKey || event.metaKey;\n                        if (getFocus) viewerRef.current.displayFocus();\n                        else viewerRef.current.centerFocus();\n                      }}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faDotCircle} />\n                    </IconButton>\n\n                    {noTrajectory || (\n                      <div className={style['stacked-icons']} title={hasPbcResidues &&\n                        'Smooth interpolation is not allowed since there are residues under Periodic Boundary Conditions. ' +\n                        'The smoothing may result in misleading artifacts for those atoms jumping across boundaries.'}>\n                        <IconButton\n                          title={`Toggle smooth interpolation ${smooth ? 'off' : 'on'}`}\n                          onClick={() => setSmooth(previous => !previous)}\n                          // If there are PBC residues then forbid the smooth to prevent misleads\n                          // Note that the smoothing may result in artifacts for those atoms jumping across boundaries\n                          // This is very clear for solvent/counter ions (breathing effect) and also visible in membrane residues\n                          disabled={hasPbcResidues}\n                          size=\"large\"\n                        >\n                          <FontAwesomeIcon icon={smooth ? faImages : faVideo} />\n                        </IconButton>\n                      </div>\n                    )}\n\n                    <IconButton\n                      title=\"Invert background color\"\n                      onClick={() => {\n                        toggleDarkBackground();\n                        setAsync('dark-background', !darkBackground);\n                      }}\n                      size=\"large\"\n                    >\n                      <div\n                        className={cn(style['background-toggle'], {\n                          [style.dark]: darkBackground,\n                        })}\n                      >\n                        <FontAwesomeIcon icon={faAdjust} />\n                      </div>\n                    </IconButton>\n\n                    <IconButton\n                      title={`Switch to ${\n                        perspective ? 'ortographic' : 'perspective'\n                      } view`}\n                      onClick={() => {\n                        togglePerspective();\n                        setAsync('perspective', !perspective);\n                      }}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={perspective ? faSquare : faCube} />\n                    </IconButton>\n\n                    <IconButton\n                      title={`Switch viwer to ${\n                        Viewer === NGLViewer ? 'MolStar' : 'NGL'\n                      }`}\n                      onClick={() => {\n                        setViewer(currentViewer => {\n                          if (currentViewer === NGLViewer) return MolstarViewer;\n                          if (currentViewer === MolstarViewer) return NGLViewer;\n                          throw new Error('Unrecognized current viewer');\n                        });\n                      }}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon\n                        icon={Viewer === NGLViewer ? faStarOfLife : faShareAlt}\n                      />\n                    </IconButton>\n                  </div>\n                  {noTrajectory || (\n                    <div>\n                      Speed:\n                      <Grid\n                        container\n                        spacing={2}\n                        className={style['extra-top-margin']}\n                      >\n                        <Grid item>\n                          <Icon>\n                            <FontAwesomeIcon icon={faWalking} />\n                          </Icon>\n                        </Grid>\n                        <Grid item xs>\n                          <Slider\n                            title=\"Change player speed\"\n                            value={speed}\n                            aria-labelledby=\"continuous-slider\"\n                            onChange={(_, value) => {\n                              setSpeed(value);\n                              setAsync('speed', value);\n                            }}\n                          />\n                        </Grid>\n                        <Grid item>\n                          <Icon>\n                            <FontAwesomeIcon icon={faBiking} />\n                          </Icon>\n                        </Grid>\n                      </Grid>\n                    </div>\n                  )}\n                  {noTrajectory || (\n                    <div>\n                      Frames:\n                      {framesSelect ? (\n                        <Slider\n                          title=\"Select frame number\"\n                          value={requestedFramesNumber}\n                          onChange={(_, value) =>\n                            setRequestedFramesNumber(value)\n                          }\n                          aria-labelledby=\"discrete-slider-restrict\"\n                          step={null}\n                          valueLabelDisplay=\"auto\"\n                          marks={frameNumbers}\n                          max={frameNumbers[frameNumbers.length - 1].value}\n                        />\n                      ) : (\n                        // DANI: Esto puede que no esté bien. Deberían ser 20 frames cuando es una PCA projection\n                        ' ' + viewerRef.current.totalExpectedFrames\n                      )}\n                    </div>\n                  )}\n                </div>\n              )}\n            </Card>\n            {settings && (\n              <div className={style['settings-right']}>\n                <RepresentationsManager\n                  components={finalComponents}\n                  representations={finalRepresentations}\n                  setRepresentations={setFinalRepresentations}\n                />\n              </div>\n            )}\n          </Card>\n          <CardContent style={{ padding: 0 }}>\n            {noTrajectory\n              // Render an empty div to avoid a Warning message since CardContent expect a ReactNode and an undefuned is not\n              ? (<div />)\n              // Render the loading/progress bar in case there is a trajectory to be loaded\n              : (<div\n                  className={cn(style.progress, { [style.dark]: darkBackground })}\n                  onClick={handleManualProgress}\n                  onMouseMove={handleManualProgress}\n                >\n                  <LinearProgress\n                    variant=\"buffer\"\n                    color=\"primary\"\n                    value={progress * 100}\n                    valueBuffer={load * 100}\n                    style={{ height: '1ch' }}\n                  />\n                </div>)\n            }\n            <div className={style.controls}>\n              <div>\n                <IconButton\n                  title=\"Close viewer\"\n                  className={cn({ [style.hidden]: !close })}\n                  disabled={!close}\n                  onClick={close}\n                  size=\"large\"\n                >\n                  <FontAwesomeIcon icon={faTimes} />\n                </IconButton>\n\n                <IconButton\n                  title={nailed ? 'Nailed viewer' : 'Nail viewer'}\n                  className={cn({ [style.hidden]: !nail })}\n                  disabled={!nail || nailed}\n                  onClick={() => {\n                    nail();\n                    toggleNailed();\n                  }}\n                  size=\"large\"\n                >\n                  <div className={style['flip-container']}>\n                    <div\n                      className={cn(style['flip-card-container'], {\n                        [style.flipped]: nailed,\n                      })}\n                    >\n                      <FontAwesomeIcon\n                        className={cn(style['flip-card'], style.front)}\n                        icon={faUnlock}\n                      />\n                      <FontAwesomeIcon\n                        className={cn(style['flip-card'], style.back)}\n                        icon={faLock}\n                      />\n                    </div>\n                  </div>\n                </IconButton>\n              </div>\n              <div>\n                {noTrajectory || (\n                  <>\n                    <IconButton\n                      title=\"Previous frame\"\n                      onClick={handlePreviousFrame}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faStepBackward} />\n                    </IconButton>\n                    <IconButton\n                      title={playing ? 'Pause' : 'Play'}\n                      onClick={togglePlaying}\n                      size=\"large\"\n                    >\n                      <div className={style['flip-container']}>\n                        <div\n                          className={cn(style['flip-card-container'], {\n                            [style.flipped]: playing,\n                          })}\n                        >\n                          <FontAwesomeIcon\n                            className={cn(style['flip-card'], style.front)}\n                            icon={faPlay}\n                          />\n                          <FontAwesomeIcon\n                            className={cn(style['flip-card'], style.back)}\n                            icon={faPause}\n                          />\n                        </div>\n                      </div>\n                    </IconButton>\n                    <IconButton\n                      title=\"Next frame\"\n                      onClick={handleNextFrame}\n                      size=\"large\"\n                    >\n                      <FontAwesomeIcon icon={faStepForward} />\n                    </IconButton>\n                  </>\n                )}\n              </div>\n              <div>\n                <IconButton\n                  title={`${isFullscreen ? 'Exit' : 'Go'} fullscreen`}\n                  onClick={handlerFullscreenButton}\n                  className={cn(style['fullscreen-toggle'], {\n                    [style.hidden]: !screenfull.isEnabled,\n                    [style['is-fullscreen']]: isFullscreen,\n                    [style['settings']]: settings,\n                  })}\n                  disabled={!screenfull.isEnabled}\n                  size=\"large\"\n                >\n                  <FontAwesomeIcon\n                    icon={isFullscreen ? faCompress : faExpand}\n                  />\n                </IconButton>\n                <IconButton\n                  title={'Settings'}\n                  onClick={() => {\n                    openSettings(previous => !previous);\n                    viewerRef.current.autoResize();\n                  }}\n                  size=\"large\"\n                >\n                  <FontAwesomeIcon icon={faCog} />\n                </IconButton>\n              </div>\n            </div>\n          </CardContent>\n        </div>\n      </Card>\n    );\n  },\n);\n\nexport default ViewerWithControls;\n","// Set the most suitable position for a tooltip\n// Use the parent element to set the limits where this tooltip may be\n// Use the tooltip element to get the suze of the tooltip\n// Use the reference position (e.g. mouse position) to place the tooltip\n// The offset is the pixels of separation between the reference and the tooltip\n// The idea is that the tooltip may be over/under and left/right of the reference position\n// It depends on how close to each limit is the reference position\nexport const setTooltipPosition = (parent, tooltip, reference, offset = 0) => {\n  const limits = parent.getBoundingClientRect();\n  const size = tooltip.getBoundingClientRect();\n  let x = reference.x;\n  // If it is more at the right side\n  if (Math.abs(limits.left - x) > Math.abs(x - limits.right)) {\n    const xSize = size.right - size.left;\n    x -= offset + xSize;\n  }\n  // If it is more at the left side\n  else {\n    x += offset;\n  }\n  // After this, apply the parent offset\n  x -= limits.left;\n  let y = reference.y;\n  // If it is more at the bottom side\n  if (Math.abs(limits.top - y) > Math.abs(y - limits.bottom)) {\n    const ySize = size.bottom - size.top;\n    y -= offset + ySize;\n  }\n  // If it is more at the top side\n  else {\n    y += offset;\n  }\n  // After this, apply the parent offset\n  y -= limits.top;\n  // Return the coordinates\n  return { x, y };\n};\n"],"names":["useDefaultRepresentations","chains","metadata","topology","useContext","ProjectCtx","file","structure","PdbCtx","useMemo","reps","ligands","LIGANDS","chainnames","CHAINNAMES","chain","name","push","selection","forEach","rep","nglSelectionExists","Array","isArray","Object","entries","_ref","indexOf","getChainByName","residues","every","residue","isLigand","type","color","opacity","ligand","ligandResidueIndices","getReferenceResidueIndices","length","rangedSelection","nglSelection","residueIndices2Ngl","ngl","singleAtomIndices","residueAtomIndices","atomIndices","singleAtomSelection","join","representedResidues","isCartoon","undefined","nglSelection2residueIndices","residuesCount","residueCount","nonRepresentedResidues","i","otherSelection","availableDrawingMethods","label","value","DrawingMethodExists","opt","availableColoringMethods","availableColors","coloringExists","memo","components","representations","setRepresentations","_jsx","_Fragment","children","_jsxs","Table","size","padding","stickyHeader","TableHead","TableRow","TableCell","align","TableBody","map","representation","index","component","scope","IconButton","title","onClick","previousRepresentations","show","FontAwesomeIcon","icon","faEye","faEyeSlash","TextField","defaultValue","variant","onKeyPress","event","key","target","disabled","custom","margin","Select","native","onChange","_ref2","cm","_ref3","customScheme","word","toUpperCase","slice","Slider","_","className","style","colSpan","Chip","faPlusCircle","KEY","concat","get","storedValue","localStorage","getItem","JSON","parse","setAsync","async","schedule","set","setItem","stringify","TrajectoryFromCustomData","StateTransformer","builderFactory","CreateTransformer","display","from","PluginStateObject","Root","to","Molecule","Coordinates","params","data","PD","Value","Uint8Array","isHidden","natoms","apply","Task","create","Error","frameSize","coordSize","byteLength","nframes","coordinates","Float32Array","frameCoordinates","count","frame","x_coords","y_coords","z_coords","atom","x","y","z","elementCount","time","Time","xyzOrdering","isIdentity","molstarCoords","customParse","getFrames","trajectoryFrames","requestedFrames","requestedFrame","range","toString","frames","frameStep","Math","floor","returnedFrames","ceil","molstarSpec","DefaultPluginUISpec","layout","initial","isExpanded","controlsDisplay","showControls","controls","top","bottom","left","remoteState","DEFAULT_NUMBER_OF_FRAMES","frameRangeFormat","defaultHighlightTypes","atoms","selections","MolstarViewer","forwardRef","ref","playing","spinning","smooth","onProgress","onLoad","bounce","requestedFramesNumber","selectedAtoms","selectedResidueIndices","selectedChains","selectedCustom","selectedDistances","selectedAngles","selectedRepresentation","snapRepresentations","noTrajectory","initialFocus","darkBackground","perspective","speed","drawingMethods","coloringMethods","opacities","showRepresentations","nglSelections","highlightTypes","comps","accession","accessionAndMdNumber","fileDescriptors","curatedOrientation","topologyManager","pdbDataFile","isFirstCompStaged","setIsFirstCompStaged","useState","focus","setFocus","parentRef","useRef","molstarRef","containerRef","stageRef","tooltipRef","inViewRef","isInView","useInView","tooltipContent","setTooltipContent","currentRequests","requestedTopologies","setRequestedTopologies","anyLoadingTopology","setAnyLoadingTopology","previousRequestedTopologies","newRequestedTopologies","comp","url","topologyURL","find","BASE_PATH_PROJECTS","MAIN_STRUCTURE_FILENAME","loading","requested","error","topologies","setTopologies","useEffect","requestedTopology","t","previous","anyLoading","some","getter","substring","https","http","request","response","on","chunk","current","mainComponent","mainTopology","pdbFile","requestedTrajectories","setRequestedTrajectories","anyLoadingTrajectory","setAnyLoadingTrajectory","payload","currentTrajectories","newTrajectories","baseUrl","c","onlyTopology","isPrincipal","urls","trajectoryURLs","frameCount","u","framed","frameRange","parsed","exec","start","groups","end","max","step","parseFrameRange","trajectoryFilename","split","trajectoryFileDescriptor","filename","trajectoryMetadata","Number","isFinite","finalUrl","maximumFrames","min","framesRange","framesCount","framedURLs","trajectory","trajectories","setTrajectories","updateLoadingProgress","useCallback","mainComp","mainTrajectories","trajectoriesState","overallFrames","reduce","a","b","overallProgress","progress","totalBytes","headers","previousTrajectories","ArrayBuffer","byteCount","currentTrajectory","buffer1","buffer2","tmp","buffer","appendBuffer","redundantList","abort","createPluginUI","wrap","dispose","molstar","builders","rawData","state","isGhost","parseTrajectory","model","createModel","modelRef","trajectoryAtoms","trajectoryFinalExpectedFrames","bytesPerFrame","BYTES_PER_COORDINATE","fitLength","totalPayload","totalFrames","coords","build","toRoot","commit","loadedTrajectories","managers","hierarchy","molstarTrajectory","TrajectoryFromModelAndCoordinates","coordinatesRef","dependsOn","newModel","createStructure","lightRepresentation","createStructureRepresentationParams","typeParams","quality","ignoreHydrogens","ignoreHydrogensVariant","ignoreLight","StateTransforms","Representation","StructureRepresentation3D","animation","play","AnimateModelIndex","duration","maxFps","mode","direction","stop","handleResize","canvas","querySelector","height","cursor","sleep","window","addEventListener","removeEventListener","useImperativeHandle","autoResize","displayFocus","orientation","viewerControls","getOrientation","stringifiedArray","elements","console","log","centerFocus","sele","currentFrame","compList","trajList","total","this","setFrame","totalExpectedFrames","expectedFrames","node","cn","payloadToNGLCoordinates","trajectoryData","trajectoryCoordinates","overallCoordinates","subarray","payloadToNGLCoordinatesFiltered","atomCount","expectedAtomNumber","k","j","e","payloadToNGLCoordinatesAlternative","format","backboneAtoms","heavyAtoms","getAtomProxy","atomname","element","DEFAULT_ORIENTATION_TRANSITION_DURATION","CHAIN_SELECTION","interpolateSpeed","currentSpeed","isMainTrajectoryStaged","setIsMainTrajectoryStaged","firstTime","originalOritentationRef","Matrix4","atomSelection","postData","protocol","requestOptions","urlParse","isStructureEndpoint","path","endsWith","method","responseContent","stringBlob","Blob","autoLoad","defaultRepresentation","ext","then","catch","write","requestPathsteps","pathname","isTrajectoryEndpoint","runningTasks","setRunningTasks","handleTasksChange","stage","Stage","tasks","signals","countChanged","add","viewerLogs","beginning","Date","now","currentTick","round","padStart","repeat","viewer","setBackground","setCamera","firstComp","trajectoryHandler","frameHandler","clamp","frameChanged","remove","atomStore","occupancy","fill","stageComp","componentObject","cloneDeep","addComponentFromObject","componentRepresentations","filter","registredNames","r","customColorScheme","colorScheme","ColormakerRegistry","addSelectionScheme","colorName","s","Option","isValidColor","parameters","colorDomain","surfaceType","side","depthWrite","other","previousRepresentation","reprList","previousType","repr","previousSelection","string","removeRepresentation","addRepresentation","setParameters","annotationList","annotation","elm","document","createElement","innerText","backgroundColor","center","structureView","addAnnotation","removeAnnotation","charAt","registredName","nameHighlight","previousHighlightRepresentation","nameContextHighlight","previousContextRepresentation","seleHighlight","atomIndex","scale","otherResidueAtomsSelection","Set","residueIndex","getAtomResidueIndex","getResidueByIndex","residueNglSelections","overallNglSelection","currentComponent","currentRepresentations","snapRepresentation","previousSnapRepresentation","currentRepresentation","atomPair","labelUnit","labelColor","atomTriple","mainNglFile","setMainNglFile","trajectoryPayloads","combinedURL","combinedProgress","fitPayload","sameTrajectory","removeTrajectory","bind","cb","nb","lastFrameIndex","completedTrajectory","trajectoryAtomIndices","compTrajectories","nglFile","nglTrajectory","updateNGLFile","currentFrames","discardBytes","newTrajectoryData","newTrajectoryFrames","_frameCount","nglPlayer","player","timeout","interpolateStep","isRunning","_currentFrame","setNGLFile","Frames","addTrajectory","goToNextFrame","haltedRunning","mainTraj","pause","spinAnimation","paused","toggleSpin","interpolateType","cancel","handler","detail","eventtype","highlight","manager","querySelectorAll","thisHiglight","attributeValues","attributes","sourceStart","getResidueByParameters","sourceEnd","chainName","number","substr","structureComponent","previousStructureRepresentation","animationControls","orient","colorSchemeID","autoView","tooltip","appendChild","mouseControls","formatOutput","metadataChainName","referenceId","resname","referenceName","isProtein","referenceNumber","hideTooltip","clearTimeout","hovered","pickingProxy","setTimeout","description","bond","atom1","atom2","setTooltipPosition","mouse","position","firstFocus","transition","LOW","Symbol","MEDIUM","HIGH","connectionLevel","navigator","connection","effectiveType","saveData","DEFAULT_STARTS_PLAYING","reducedMotion","innerWidth","DEFAULT_FRAME_NUMBER","DEFAULT_FRAME_NUMBERS","DEFAULT_COMPONENT_PARAMETERS","DEFAULT_REPRESENTATION_PARAMETERS","completeMissingFields","targetObject","defaultValuesObject","anyChange","fieldName","startingComponents","startingRepresentations","componentsState","representationsState","startsPlaying","close","nail","framesSelect","preventTrajectory","props","Viewer","setViewer","NGLViewer","frameNumbers","maximumSnapshots","mdFrames","pop","fixedStartingComponents","finalComponents","setFinalComponents","completeComponentMissingFields","defaults","defComponents","componentNames","uniqueComponentNames","v","fixedStartingRepresentations","finalRepresentations","setFinalRepresentations","defaultRepresentations","completeRepresentationMissingFields","defRepresentations","viewerRef","nailed","toggleNailed","useToggleState","togglePlaying","toggleSpinning","setSmooth","toggleDarkBackground","togglePerspective","setProgress","load","setLoad","isFullscreen","setIsFullscreen","screenfull","setRequestedFramesNumber","setSpeed","settings","openSettings","handleProgress","prog","handleLoad","handleManualProgress","buttons","clientX","currentTarget","width","getBoundingClientRect","handleFrameChange","handlePreviousFrame","handleNextFrame","handleFullscreenChange","handlerFullscreenButton","handleKeyPress","hasPbcResidues","pbcResidues","_hasPbcResidues","Card","border","boxShadow","id","faSyncAlt","shiftKey","ctrlKey","metaKey","faDotCircle","faImages","faVideo","faAdjust","faSquare","faCube","currentViewer","faStarOfLife","faShareAlt","Grid","container","spacing","item","Icon","faWalking","xs","faBiking","valueLabelDisplay","marks","RepresentationsManager","CardContent","onMouseMove","LinearProgress","valueBuffer","faTimes","faUnlock","faLock","faStepBackward","faPlay","faPause","faStepForward","faCompress","faExpand","faCog","parent","reference","offset","arguments","limits","abs","right"],"sourceRoot":""}