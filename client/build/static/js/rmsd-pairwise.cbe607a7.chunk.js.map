{"version":3,"file":"static/js/rmsd-pairwise.cbe607a7.chunk.js","mappings":"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","sources":["components/ngl-viewer/use-default-representations/index.js","webpack://mdposit/./src/pages/accession/rmsd-pairwise/style.module.css?bc81","pages/accession/rmsd-pairwise/index.js"],"sourcesContent":["// React logic\nimport { useMemo, useContext } from 'react';\n\nimport { ProjectCtx, PdbCtx } from '../../../contexts';\n\nimport { nglSelection2residueIndices, nglSelectionExists } from '../../../utils/topology-manager';\n\n// Use this hook to get the memoized NGL default representations\nconst useDefaultRepresentations = () => {\n  // Get the current project metadata and chains\n  const { chains, metadata, topology } = useContext(ProjectCtx);\n  // Get current structure\n  const { file: structure } = useContext(PdbCtx);\n  //console.log(structure.residueMap.get(0).isCg());\n  // Set the chains to be represented in the NGL viewer by default\n  // WARNING: This is experimental and may have some bugs\n  const defaultRepresentations = useMemo(() => {\n    if (!topology) return [];\n    const reps = [];\n    const ligands = metadata && metadata.LIGANDS;\n    if (metadata && chains) {\n      const chainnames = metadata.CHAINNAMES;\n      // Represent each protein chain\n      if (chainnames) {\n        for (const chain of chains) {\n          const name = chainnames[chain];\n          reps.push({\n            name: name ? name + ' (Chain ' + chain + ')' : 'Chain ' + chain,\n            selection: ':' + chain,\n          });\n        }\n      }\n      // If chainnames are not defined then set a general representation\n      else {\n        const generalRepresentations = [\n          { name: 'Protein', selection: 'protein' },\n          { name: 'Nucleic acids', selection: 'nucleic' }\n        ]\n        // Add the representation only if it contains any atom\n        generalRepresentations.forEach(rep => {\n          const exists = nglSelectionExists(rep.selection, structure);\n          if (exists) reps.push(rep);\n        });\n      }\n\n      // Represent the mebrane if exist\n      /*\n          if (metadata.MEMBRANE !== 'No')\n              reps.push({\n              selection: '(not polymer or hetero) and not (water or ion)',\n              name: metadata.MEMBRANE,\n              type: 'licorice',\n              opacity: 0.5,\n              });\n          */\n      // Represent all chains which are not in the 'chains' and 'ligands' list in licorice\n      if (chainnames && !Array.isArray(chainnames)) {\n        const chainsAndNames = Object.entries(chainnames);\n        chainsAndNames.forEach(([chain, name]) => {\n          // Check if the chain is in the protein chains\n          const isProtein = chains.indexOf(chain) !== -1;\n          if (isProtein) return;\n          // Check if the chain is full ligand\n          // DANI: No se ha probado\n          const topologyChain = topology.getChainByName(chain);\n          const isLigand = topologyChain.residues.every(residue => residue.isLigand);\n          // If there is any coincidence then skip this chainname\n          if (isLigand) return;\n          reps.push({\n            name: name,\n            selection: ':' + chain,\n            type: 'licorice',\n            color: 'purple',\n            opacity: 0.5,\n          });\n        });\n      }\n    }\n    // If there is no metadata/chains then set up a defualt generic representation\n    else {\n      reps.push({ name: 'Main structure' });\n    }\n\n    // Display ligands\n    if (ligands) {\n      for (const ligand of ligands) {\n        // New system: ligands are pubchem ids\n        if (typeof ligand === 'string') {\n          // Get ligand reisude indcies\n          const ligandResidueIndices = topology.getReferenceResidueIndices(ligand);\n          if (!ligandResidueIndices || ligandResidueIndices.length === 0) continue;\n          // Transform the residue indices to a NGL selection\n          const { rangedSelection: nglSelection } = topology.residueIndices2Ngl(ligandResidueIndices);\n          // Add the representation\n          reps.push({\n            name: ligand,\n            selection: nglSelection,\n            type: 'ball+stick',\n            color: 'element'\n          });\n        }\n        // Old system: ligands are objects which may have a ngl selection\n        else{\n          if (!ligand.ngl) continue;\n          reps.push({\n            name: ligand.name,\n            selection: ligand.ngl,\n            type: 'licorice',\n          });\n        }\n        \n      }\n    }\n\n    // Add a representation for ions in spacefill in case there are residues with 1 atom\n    const singleAtomIndices = []\n    topology.residueAtomIndices.forEach(atomIndices => {\n      if (atomIndices.length > 1) return;\n      singleAtomIndices.push(atomIndices[0]);\n    })\n    if (singleAtomIndices.length > 0) {\n      const singleAtomSelection = '@' + singleAtomIndices.join(',');\n      reps.push({\n        name: 'Ions',\n        selection: singleAtomSelection,\n        type: 'spacefill',\n        color: 'element',\n      });\n    }\n\n    // Represent \"Other\" residues in low opacity grey licorice\n    // Get all residues which are not already included on any previous section\n    // Get also all residues which are represented as cartoon but are not protein or nucleic acid\n    // i.e. residues which would not be represented by now\n    const representedResidues = [];\n    reps.forEach(rep => {\n      const isCartoon = rep.type === undefined || rep.type === 'cartoon';\n      const residues = nglSelection2residueIndices(\n        rep.selection,\n        isCartoon,\n        structure,\n      );\n      representedResidues.push(...residues);\n    });\n    const residuesCount = topology.residueCount;\n    const nonRepresentedResidues = [];\n    for (let i = 0; i < residuesCount; i++) {\n      if (representedResidues.indexOf(i) === -1) nonRepresentedResidues.push(i);\n    }\n    if (nonRepresentedResidues.length > 0) {\n      const {\n        rangedSelection: otherSelection,\n      } = topology.residueIndices2Ngl(nonRepresentedResidues);\n      reps.push({\n        name: 'Other',\n        selection: otherSelection,\n        type: 'licorice',\n        color: 'grey',\n        opacity: 0.3,\n      });\n    }\n\n    return reps;\n  }, [chains, metadata, topology, structure]);\n\n  return defaultRepresentations;\n};\n\nexport default useDefaultRepresentations;\n","// extracted by mini-css-extract-plugin\nexport default {\"widest\":\"style_widest__hZ7sO\",\"margined\":\"style_margined__GphyO\",\"margined-bottom\":\"style_margined-bottom__KpiYO\",\"horizontal\":\"style_horizontal__1xLer\"};","import React, { useContext, useState, useMemo, useRef } from 'react';\n\nimport { CardContent, Chip, Typography } from '@mui/material';\n\nimport useAPI from '../../../hooks/use-api';\n\nimport Card from '../../../components/animated-card';\nimport Loading from '../../../components/loading';\nimport ViewerSpawner from '../../../components/viewer-spawner';\nimport useDefaultRepresentations from '../../../components/ngl-viewer/use-default-representations';\n\nimport { ProjectCtx } from '../../../contexts';\n\nimport { BASE_PATH_PROJECTS } from '../../../utils/constants';\n\nimport style from './style.module.css';\n\nimport InteractionSelector from '../../../components/interaction-selector';\nimport Heatmap from '../../../components/heatmap';\n\n// Keep constant representation references to keep them between renders\nconst REPRESENTATION_REFERENCES = {\n  base: ['First frame', 'Second frame'],\n  interface: ['First frame interface', 'Second frame interface']\n}\n\n// Set the representation colors\nconst REPRESENTATION_COLORS = {\n  base: ['red', 'blue'],\n  interface: [\n    ['orange', 'yellow'], // Agent 1\n    ['purple', 'green'], // Agent 2\n  ] \n}\n\nconst RmsdPairwise = () => {\n  // Get the current project data\n  const {\n    accessionAndMdNumber,\n    metadata,\n    interactions: defaultInteractions,\n    topology: topologyManager,\n  } = useContext(ProjectCtx);\n\n  // Set a ref to the ngl which allows access to the ngl viewer exposed methods\n  const viewerRef = useRef(null);\n  // Get the default representations\n  const defaultRepresentations = useDefaultRepresentations();\n  // The selected frames\n  const [selectedFramePair, setSelectedFramePair] = useState(null);\n  // The interaction to be displayed\n  const [selectedInteraction, setSelectedInteraction] = useState(0);\n  // Get analysis data from the API\n  const url = `${BASE_PATH_PROJECTS}/${accessionAndMdNumber}/analyses/rmsd-pairwise/`;\n  const { loading, payload, error } = useAPI(url);\n  // Set the available interactions\n  const interactions = useMemo(() => {\n    if (!defaultInteractions) return [{ name: 'Overall' }];\n    // Label all metadata interactions with the 'interface residues' ending\n    defaultInteractions.forEach(interaction => {\n      interaction.label = interaction.name + ' (interface residues)';\n    });\n    const interactions = [{ name: 'Overall' }, ...defaultInteractions];\n    return interactions;\n  }, [defaultInteractions]);\n  // Process analysis data for the heatmap\n  const { rmsds, AxesValues } = useMemo(() => {\n    // Return if the payload is not ready\n    if (!payload) return {};\n    // Get the selected interaction\n    const interaction = interactions[selectedInteraction];\n    // Get the data whose name matches the interaction name\n    const data = payload.data.find(dataset => dataset.name === interaction.name);\n    if (!data) throw new Error(`Dataset for interaction \"${interaction.name}\" not found`);\n    // Get the rmsds values\n    const rmsds = data.rmsds;\n    // Calculate the step\n    // DANI: Esto no es del todo correcto pero hace que los números de frames siempre cuadren\n    const dataLength = rmsds.length;\n    const AxesStep = Math.floor(metadata.mdFrames / (dataLength - 1));\n    // DANI: Esto es lo correcto\n    // DANI: En algunos análisis antiguos las frames no cuadran y hay que rehacerlos\n    //const xAxesStep = payload.step;\n    // Calculate the frames labels\n    // These values are used for BOTH axes\n    const AxesValues = Array(dataLength)\n      .fill(undefined)\n      .map((v, i) => i * AxesStep);\n    return { rmsds, AxesValues };\n  }, [payload, metadata, interactions, selectedInteraction]);\n\n  // Set the component state\n  const [components, setComponents] = useState(null);\n\n  // Set the components value\n  useMemo(() => {\n    // If there is no selected pair then set the components as null\n    if (!selectedFramePair) return setComponents(null);\n    // If a frame pair is selected then set the components or update them accordingly\n    setComponents(previousComponents => {\n      // If there are no previous components then set them from scratch\n      if (previousComponents === null) {\n        return selectedFramePair.map(frame => ({\n          name: `Frame ${frame}`,\n          frame: frame\n        }));\n      }\n      // If components already exists then just update them\n      selectedFramePair.forEach((frame, index) => {\n        const previousComponent = previousComponents[index];\n        previousComponent.name = `Frame ${frame}`;\n        previousComponent.frame = frame;\n      });\n      return [...previousComponents];\n    });\n  }, [selectedFramePair]);\n\n  // Set the component state\n  const [representations, setRepresentations] = useState(null);\n\n  // Set the viewer representations\n  useMemo(() => {\n    // If there are no components then clear the representations and stop here\n    if (!components) return setRepresentations(null);\n    // Get the selected interaction\n    const interaction = interactions[selectedInteraction];\n    // Get also the number of the interacting agents\n    const agents = [\n      { name: interaction.agent_1, interface: interaction.interface_indices_1 },\n      { name: interaction.agent_2, interface: interaction.interface_indices_2 }\n    ];\n    // Setup every representation or update the already existing ones\n    setRepresentations(previousRepresentations => {\n      // Set a list to keep updated representations\n      const newRepresentations = [];\n      // Find out if there is a selected interaction\n      const currentInteraction = selectedInteraction > 0;\n      // Find out if there was a selected interaction in the previous representations\n      const previousInteraction = !!(previousRepresentations && previousRepresentations.find(\n        rep => rep.reference && rep.reference.includes(REPRESENTATION_REFERENCES.interface[0])));\n      // Check if there was interactions in the previous\n      // If there were no previous representations then set the default values\n      if (previousRepresentations === null) {\n        components.forEach((component, index) => {\n          // Set the overall representations\n          // In case there is no interaction selected this would be opaque\n          // In case there is an interaction selected this would be transparent (just a reference)\n          defaultRepresentations.forEach(representation => {\n            const newRepresentation = { ...representation };\n            newRepresentation.name = `${component.name} - ${representation.name}`;\n            newRepresentation.color = REPRESENTATION_COLORS.base[index];\n            newRepresentation.component = component.name;\n            newRepresentation.reference = `${REPRESENTATION_REFERENCES.base[index]} - ${representation.name}`;\n            if (currentInteraction) {\n              newRepresentation.name += ' reference';\n              newRepresentation.opacity = 0.1;\n            }\n            newRepresentations.push(newRepresentation);\n          });\n        });\n      }\n      // If representations already exist then update them\n      else {\n        components.forEach((component, index) => {\n          // Iterate the default representations\n          defaultRepresentations.forEach(representation => {\n            // Find the previous corresponding representation\n            const reference = `${REPRESENTATION_REFERENCES.base[index]} - ${representation.name}`;\n            const previousRepresentation = previousRepresentations.find(rep => rep.reference === reference);\n            if (!previousRepresentation) throw new Error(`No previous representation with reference ${reference}`);\n            // Update the representation name and component\n            const previousComponentName = previousRepresentation.name.split(' - ')[0];\n            previousRepresentation.name = previousRepresentation.name.replace(previousComponentName, component.name);\n            previousRepresentation.component = component.name;\n            // Add or remove the 'reference' tail from the name and update the opacity\n            // If we passed from no selected interaction to selected interaction\n            if (currentInteraction && !previousInteraction) {\n              previousRepresentation.name += ' reference';\n              previousRepresentation.opacity = 0.1;\n            }\n            // If we passed from selected interaction to no selected interaction\n            if (!currentInteraction && previousInteraction) {\n              previousRepresentation.name = previousRepresentation.name.replace(' reference', '');\n              previousRepresentation.opacity = 1;\n            }\n            newRepresentations.push(previousRepresentation);\n          });\n        });\n      }\n      // Set interfaces representations, each with different colors\n      if (currentInteraction) {\n        // If we did not have a selected interaction then setup representations with default values\n        if (previousInteraction === false) {\n          components.forEach((component, index) => {\n            agents.forEach((agent, agentIndex) => {\n              // Get the interaction interface, if it exists, in NGL format\n              // The default interaction (Overall) has no interface\n              const selection = agent.interface && topologyManager.residueIndices2Ngl(agent.interface);\n              // Set the new representation\n              newRepresentations.push({\n                name: `${component.name} - ${agent.name} interface`,\n                color: REPRESENTATION_COLORS.interface[index][agentIndex],\n                selection: selection.rangedSelection,\n                type: 'licorice',\n                component: component.name,\n                reference: `${REPRESENTATION_REFERENCES.interface[index]} - ${agent.name}`\n              });\n            });\n          });\n        }\n        // Otherwise update the already existing representations\n        else {\n          components.forEach((component, index) => {\n            agents.forEach(agent => {\n              // Get the interaction interface, if it exists, in NGL format\n              // The default interaction (Overall) has no interface\n              const selection = agent.interface && topologyManager.residueIndices2Ngl(agent.interface);\n              // Find the previous representation for interface 1\n              const reference = `${REPRESENTATION_REFERENCES.interface[index]} - ${agent.name}`;\n              const previousRepresentation = previousRepresentations.find(\n                rep => rep.reference === reference\n              );\n              // Update its name, selection and component\n              previousRepresentation.name = `${component.name} - ${agent.name} interface`;\n              previousRepresentation.selection = selection.rangedSelection;\n              previousRepresentation.component = component.name;\n              newRepresentations.push(previousRepresentation);\n            });\n          });\n        }\n      }\n      // Add previous custom representations (added by the user)\n      previousRepresentations && previousRepresentations.filter(rep => rep.custom)\n        .forEach(representation => {\n          // Update the component to target the first component\n          representation.component = components[0].name;\n          newRepresentations.push(representation);\n        });\n      // Update the representations state\n      return newRepresentations;\n    });\n  }, [\n    components,\n    topologyManager,\n    interactions,\n    selectedInteraction,\n    defaultRepresentations,\n  ]);\n\n  // Render loading or error messages according with the API response\n  if (loading) return <Loading />;\n  else if (error) return error.toString();\n  else if (!payload) return 'Something bad happened';\n\n  // Render\n  return (\n    <>\n      <Card>\n        <CardContent className={style.horizontal}>\n          <Typography variant=\"h6\">Residues selection:</Typography>\n          <InteractionSelector\n            interactions={interactions}\n            selectedInteraction={selectedInteraction}\n            setSelectedInteraction={setSelectedInteraction}\n          />\n          {selectedFramePair && (\n            <div>\n              {components && components.map((component, c) => (\n                <Chip key={c} label={'Frame ' + component.frame}\n                  style={{\n                    margin: '0.2em',\n                    backgroundColor: c === 0 ? 'red' : 'blue',\n                  }}\n                />\n              ))}\n              {selectedInteraction > 0 && components && components.map((component, c) => {\n                  // Get the interacting agents\n                  const interaction = interactions[selectedInteraction];\n                  const agents = [ interaction.agent_1, interaction.agent_2 ];\n                  // Generate a chip for every agent\n                  return agents.map((agent, a) => (\n                    <Chip key={a} label={'Frame ' + component.frame + ' - ' + agent}\n                      style={{\n                        margin: '0.2em',\n                        backgroundColor: a === 0\n                          ? c === 0\n                            ? 'orange'\n                            : 'purple'\n                          : c === 0\n                            ? 'yellow'\n                            : 'green',\n                      }}\n                    />\n                  ));\n                }\n              )}\n            </div>\n          )}\n        </CardContent>\n      </Card>\n      <Card className={style.margined} id=\"heatmap\">\n        <CardContent>\n          <Heatmap\n            inputData={{\n              data: rmsds,\n              xLabels: AxesValues,\n              yLabels: AxesValues,\n            }}\n            onTooltip={({ value, xAxisValue, yAxisValue }) =>\n              `${xAxisValue} - ${yAxisValue}\\n${Math.round(value * 100) / 100} Å`\n            }\n            onClick={({ xAxisValue, yAxisValue }) =>\n              setSelectedFramePair([xAxisValue, yAxisValue])\n            }\n            legendTitle={'RMSD (Å)'}\n            maxColor={'red'}\n            minColor={'blue'}\n            xTitle={'Frames'}\n            yTitle={'Frames'}\n          />\n        </CardContent>\n      </Card>\n      <ViewerSpawner\n        // Set a viewer if there is selected frames\n        newViewer={components\n          ? {\n              componentsState: [components, setComponents],\n              representationsState: [representations, setRepresentations],\n              selRef: selectedFramePair,\n              viewerRef: viewerRef\n            }\n          : null\n        }\n        // If the nailed/closed viewer is the current viewer then reset the 'selected'\n        onNail={viewer =>\n          setSelectedFramePair(previous => {\n            if (viewer.selRef === previous) return null;\n            else return previous;\n          })\n        }\n        onClose={viewer =>\n          setSelectedFramePair(previous => {\n            if (viewer.selRef === previous) return null;\n            else return previous;\n          })\n        }\n      />\n    </>\n  );\n};\n\nexport default RmsdPairwise;\n"],"names":["useDefaultRepresentations","chains","metadata","topology","useContext","ProjectCtx","file","structure","PdbCtx","useMemo","reps","ligands","LIGANDS","chainnames","CHAINNAMES","chain","name","push","selection","forEach","rep","nglSelectionExists","Array","isArray","Object","entries","_ref","indexOf","getChainByName","residues","every","residue","isLigand","type","color","opacity","ligand","ligandResidueIndices","getReferenceResidueIndices","length","rangedSelection","nglSelection","residueIndices2Ngl","ngl","singleAtomIndices","residueAtomIndices","atomIndices","singleAtomSelection","join","representedResidues","isCartoon","undefined","nglSelection2residueIndices","residuesCount","residueCount","nonRepresentedResidues","i","otherSelection","REPRESENTATION_REFERENCES","base","interface","REPRESENTATION_COLORS","RmsdPairwise","accessionAndMdNumber","interactions","defaultInteractions","topologyManager","viewerRef","useRef","defaultRepresentations","selectedFramePair","setSelectedFramePair","useState","selectedInteraction","setSelectedInteraction","url","concat","BASE_PATH_PROJECTS","loading","payload","error","useAPI","interaction","label","rmsds","AxesValues","data","find","dataset","Error","dataLength","AxesStep","Math","floor","mdFrames","fill","map","v","components","setComponents","previousComponents","frame","index","previousComponent","representations","setRepresentations","agents","agent_1","interface_indices_1","agent_2","interface_indices_2","previousRepresentations","newRepresentations","currentInteraction","previousInteraction","reference","includes","component","representation","newRepresentation","previousRepresentation","previousComponentName","split","replace","agent","agentIndex","filter","custom","_jsx","Loading","toString","_jsxs","_Fragment","children","Card","CardContent","className","style","Typography","variant","InteractionSelector","c","Chip","margin","backgroundColor","a","id","Heatmap","inputData","xLabels","yLabels","onTooltip","value","xAxisValue","yAxisValue","round","onClick","_ref2","legendTitle","maxColor","minColor","xTitle","yTitle","ViewerSpawner","newViewer","componentsState","representationsState","selRef","onNail","viewer","previous","onClose"],"sourceRoot":""}